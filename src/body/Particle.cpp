#include "Particle.h"

#include "utils/ArrayUtils.h"
#include "spdlog/spdlog.h"

Particle::Particle(int type_arg): Particle({0, 0, 0}, {0, 0, 0}, 0, type_arg) {
    spdlog::trace("Particle generated!");
}

Particle::Particle(const Particle &other): x(other.x), v(other.v), f(other.f), old_f(other.old_f), id(other.id),
m(other.m), type(other.type), inDomain(other.inDomain), epsilon(other.epsilon), sigma(other.sigma), k(other.k),
r0(other.r0), neighbours(other.neighbours), diagonalNeighbours(other.diagonalNeighbours), stationary(other.stationary) {
    // coping the monitor state is not required as it does not happen during simulations.
#ifdef _OPENMP
    omp_init_lock(&monitor);
#endif
    spdlog::trace("Particle generated by copy!");
}

Particle::Particle(std::array<double, 3> x_arg, std::array<double, 3> v_arg,
                   double m_arg, int type_arg) : Particle(x_arg, v_arg, m_arg, type_arg, 5, 1) {}


Particle::Particle(std::array<double, 3> x_arg, std::array<double, 3> v_arg, double m_arg, int type, double epsilon,
                   double sigma, bool stationary): id(numberParticles), x(x_arg), v(v_arg), f{0., 0., 0.}, old_f{0., 0., 0.}, m(m_arg), type(type), inDomain(
        true), epsilon(epsilon), sigma(sigma), k(0), r0(0), stationary(stationary){
    numberParticles++;
#ifdef _OPENMP
    omp_init_lock(&monitor);
#endif
    spdlog::trace("Particle generated!");
}

Particle::~Particle() {
#ifdef _OPENMP
    omp_destroy_lock(&monitor);
#endif
    spdlog::trace("Particle destructed!");
}


void Particle::removeFromDomain() {
    inDomain = false;
}

std::string Particle::toString() const {
  std::stringstream stream;
  stream << "Particle: x:" << x << " v: " << v << " f: " << f
         << " type: " << type;
  return stream.str();
}


bool Particle::operator==(const Particle &other) const {
    double delta_abs = 1e-10;
    double delta_rel = 1e-5;
    for (int i = 0; i < 3; ++i) {
        if (std::abs(x[i] - other.x[i]) > delta_rel * std::max(std::abs(x[i]), std::abs(other.x[i])) + delta_abs) {
            return false;
        }
    }
    for (int i = 0; i < 3; ++i) {
        if (std::abs(v[i] - other.v[i]) > delta_rel * std::max(std::abs(v[i]), std::abs(other.v[i])) + delta_abs) {
            return false;
        }
    }
    for (int i = 0; i < 3; ++i) {
        if (std::abs(f[i] - other.f[i]) > delta_rel * std::max(std::abs(f[i]), std::abs(other.f[i])) + delta_abs) {
            return false;
        }
    }
    if (std::abs(m - other.m) > delta_rel * std::max(std::abs(m), std::abs(other.m)) + delta_abs) {
        return false;
    }

    if (std::abs(epsilon - other.epsilon) > delta_rel * std::max(std::abs(epsilon), std::abs(other.epsilon)) + delta_abs) {
        return false;
    }

    if (std::abs(sigma - other.sigma) > delta_rel * std::max(std::abs(sigma), std::abs(other.sigma)) + delta_abs) {
        return false;
    }
    return type == other.type;
}

std::ostream &operator<<(std::ostream &stream, Particle &p) {
  stream << p.toString();
  return stream;
}
