// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "InputData.h"

// Dimension
// 


// PositiveDouble
// 


// DoubleVector3
// 

const DoubleVector3::x_type& DoubleVector3::
x () const
{
  return this->x_.get ();
}

DoubleVector3::x_type& DoubleVector3::
x ()
{
  return this->x_.get ();
}

void DoubleVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

const DoubleVector3::y_type& DoubleVector3::
y () const
{
  return this->y_.get ();
}

DoubleVector3::y_type& DoubleVector3::
y ()
{
  return this->y_.get ();
}

void DoubleVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

const DoubleVector3::z_optional& DoubleVector3::
z () const
{
  return this->z_;
}

DoubleVector3::z_optional& DoubleVector3::
z ()
{
  return this->z_;
}

void DoubleVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void DoubleVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

DoubleVector3::z_type DoubleVector3::
z_default_value ()
{
  return z_type (0.0);
}


// OptionalDoubleVector3
// 

const OptionalDoubleVector3::x_optional& OptionalDoubleVector3::
x () const
{
  return this->x_;
}

OptionalDoubleVector3::x_optional& OptionalDoubleVector3::
x ()
{
  return this->x_;
}

void OptionalDoubleVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

void OptionalDoubleVector3::
x (const x_optional& x)
{
  this->x_ = x;
}

OptionalDoubleVector3::x_type OptionalDoubleVector3::
x_default_value ()
{
  return x_type (0.0);
}

const OptionalDoubleVector3::y_optional& OptionalDoubleVector3::
y () const
{
  return this->y_;
}

OptionalDoubleVector3::y_optional& OptionalDoubleVector3::
y ()
{
  return this->y_;
}

void OptionalDoubleVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

void OptionalDoubleVector3::
y (const y_optional& x)
{
  this->y_ = x;
}

OptionalDoubleVector3::y_type OptionalDoubleVector3::
y_default_value ()
{
  return y_type (0.0);
}

const OptionalDoubleVector3::z_optional& OptionalDoubleVector3::
z () const
{
  return this->z_;
}

OptionalDoubleVector3::z_optional& OptionalDoubleVector3::
z ()
{
  return this->z_;
}

void OptionalDoubleVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void OptionalDoubleVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

OptionalDoubleVector3::z_type OptionalDoubleVector3::
z_default_value ()
{
  return z_type (0.0);
}


// PositiveIntVector2
// 

const PositiveIntVector2::x_type& PositiveIntVector2::
x () const
{
  return this->x_.get ();
}

PositiveIntVector2::x_type& PositiveIntVector2::
x ()
{
  return this->x_.get ();
}

void PositiveIntVector2::
x (const x_type& x)
{
  this->x_.set (x);
}

const PositiveIntVector2::y_type& PositiveIntVector2::
y () const
{
  return this->y_.get ();
}

PositiveIntVector2::y_type& PositiveIntVector2::
y ()
{
  return this->y_.get ();
}

void PositiveIntVector2::
y (const y_type& x)
{
  this->y_.set (x);
}


// PositiveIntVector3
// 

const PositiveIntVector3::x_type& PositiveIntVector3::
x () const
{
  return this->x_.get ();
}

PositiveIntVector3::x_type& PositiveIntVector3::
x ()
{
  return this->x_.get ();
}

void PositiveIntVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

const PositiveIntVector3::y_type& PositiveIntVector3::
y () const
{
  return this->y_.get ();
}

PositiveIntVector3::y_type& PositiveIntVector3::
y ()
{
  return this->y_.get ();
}

void PositiveIntVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

const PositiveIntVector3::z_optional& PositiveIntVector3::
z () const
{
  return this->z_;
}

PositiveIntVector3::z_optional& PositiveIntVector3::
z ()
{
  return this->z_;
}

void PositiveIntVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void PositiveIntVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

PositiveIntVector3::z_type PositiveIntVector3::
z_default_value ()
{
  return z_type (1ULL);
}


// PositiveDoubleVector3
// 

const PositiveDoubleVector3::x_type& PositiveDoubleVector3::
x () const
{
  return this->x_.get ();
}

PositiveDoubleVector3::x_type& PositiveDoubleVector3::
x ()
{
  return this->x_.get ();
}

void PositiveDoubleVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

void PositiveDoubleVector3::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const PositiveDoubleVector3::y_type& PositiveDoubleVector3::
y () const
{
  return this->y_.get ();
}

PositiveDoubleVector3::y_type& PositiveDoubleVector3::
y ()
{
  return this->y_.get ();
}

void PositiveDoubleVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

void PositiveDoubleVector3::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const PositiveDoubleVector3::z_optional& PositiveDoubleVector3::
z () const
{
  return this->z_;
}

PositiveDoubleVector3::z_optional& PositiveDoubleVector3::
z ()
{
  return this->z_;
}

void PositiveDoubleVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void PositiveDoubleVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

void PositiveDoubleVector3::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}

PositiveDoubleVector3::z_type PositiveDoubleVector3::
z_default_value ()
{
  return z_type (1.0);
}


// ParticleType
// 

const ParticleType::position_type& ParticleType::
position () const
{
  return this->position_.get ();
}

ParticleType::position_type& ParticleType::
position ()
{
  return this->position_.get ();
}

void ParticleType::
position (const position_type& x)
{
  this->position_.set (x);
}

void ParticleType::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const ParticleType::velocity_optional& ParticleType::
velocity () const
{
  return this->velocity_;
}

ParticleType::velocity_optional& ParticleType::
velocity ()
{
  return this->velocity_;
}

void ParticleType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void ParticleType::
velocity (const velocity_optional& x)
{
  this->velocity_ = x;
}

void ParticleType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const ParticleType::mass_type& ParticleType::
mass () const
{
  return this->mass_.get ();
}

ParticleType::mass_type& ParticleType::
mass ()
{
  return this->mass_.get ();
}

void ParticleType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void ParticleType::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}

const ParticleType::type_optional& ParticleType::
type () const
{
  return this->type_;
}

ParticleType::type_optional& ParticleType::
type ()
{
  return this->type_;
}

void ParticleType::
type (const type_type& x)
{
  this->type_.set (x);
}

void ParticleType::
type (const type_optional& x)
{
  this->type_ = x;
}

ParticleType::type_type ParticleType::
type_default_value ()
{
  return type_type (0);
}

const ParticleType::epsilon_optional& ParticleType::
epsilon () const
{
  return this->epsilon_;
}

ParticleType::epsilon_optional& ParticleType::
epsilon ()
{
  return this->epsilon_;
}

void ParticleType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void ParticleType::
epsilon (const epsilon_optional& x)
{
  this->epsilon_ = x;
}

ParticleType::epsilon_type ParticleType::
epsilon_default_value ()
{
  return epsilon_type (5.0);
}

const ParticleType::sigma_optional& ParticleType::
sigma () const
{
  return this->sigma_;
}

ParticleType::sigma_optional& ParticleType::
sigma ()
{
  return this->sigma_;
}

void ParticleType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void ParticleType::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

ParticleType::sigma_type ParticleType::
sigma_default_value ()
{
  return sigma_type (1.0);
}


// CuboidType
// 

const CuboidType::size_type& CuboidType::
size () const
{
  return this->size_.get ();
}

CuboidType::size_type& CuboidType::
size ()
{
  return this->size_.get ();
}

void CuboidType::
size (const size_type& x)
{
  this->size_.set (x);
}

void CuboidType::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const CuboidType::distance_type& CuboidType::
distance () const
{
  return this->distance_.get ();
}

CuboidType::distance_type& CuboidType::
distance ()
{
  return this->distance_.get ();
}

void CuboidType::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void CuboidType::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}

const CuboidType::brown_velocity_optional& CuboidType::
brown_velocity () const
{
  return this->brown_velocity_;
}

CuboidType::brown_velocity_optional& CuboidType::
brown_velocity ()
{
  return this->brown_velocity_;
}

void CuboidType::
brown_velocity (const brown_velocity_type& x)
{
  this->brown_velocity_.set (x);
}

void CuboidType::
brown_velocity (const brown_velocity_optional& x)
{
  this->brown_velocity_ = x;
}

CuboidType::brown_velocity_type CuboidType::
brown_velocity_default_value ()
{
  return brown_velocity_type (0.0);
}


// SphereType
// 

const SphereType::radius_type& SphereType::
radius () const
{
  return this->radius_.get ();
}

SphereType::radius_type& SphereType::
radius ()
{
  return this->radius_.get ();
}

void SphereType::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const SphereType::distance_type& SphereType::
distance () const
{
  return this->distance_.get ();
}

SphereType::distance_type& SphereType::
distance ()
{
  return this->distance_.get ();
}

void SphereType::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void SphereType::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}

const SphereType::brown_velocity_optional& SphereType::
brown_velocity () const
{
  return this->brown_velocity_;
}

SphereType::brown_velocity_optional& SphereType::
brown_velocity ()
{
  return this->brown_velocity_;
}

void SphereType::
brown_velocity (const brown_velocity_type& x)
{
  this->brown_velocity_.set (x);
}

void SphereType::
brown_velocity (const brown_velocity_optional& x)
{
  this->brown_velocity_ = x;
}

SphereType::brown_velocity_type SphereType::
brown_velocity_default_value ()
{
  return brown_velocity_type (0.0);
}


// ExternalForceType
// 

const ExternalForceType::index_sequence& ExternalForceType::
index () const
{
  return this->index_;
}

ExternalForceType::index_sequence& ExternalForceType::
index ()
{
  return this->index_;
}

void ExternalForceType::
index (const index_sequence& s)
{
  this->index_ = s;
}

const ExternalForceType::force_type& ExternalForceType::
force () const
{
  return this->force_.get ();
}

ExternalForceType::force_type& ExternalForceType::
force ()
{
  return this->force_.get ();
}

void ExternalForceType::
force (const force_type& x)
{
  this->force_.set (x);
}

void ExternalForceType::
force (::std::unique_ptr< force_type > x)
{
  this->force_.set (std::move (x));
}

const ExternalForceType::until_type& ExternalForceType::
until () const
{
  return this->until_.get ();
}

ExternalForceType::until_type& ExternalForceType::
until ()
{
  return this->until_.get ();
}

void ExternalForceType::
until (const until_type& x)
{
  this->until_.set (x);
}

void ExternalForceType::
until (::std::unique_ptr< until_type > x)
{
  this->until_.set (std::move (x));
}


// MembraneType
// 

const MembraneType::size_type& MembraneType::
size () const
{
  return this->size_.get ();
}

MembraneType::size_type& MembraneType::
size ()
{
  return this->size_.get ();
}

void MembraneType::
size (const size_type& x)
{
  this->size_.set (x);
}

void MembraneType::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const MembraneType::distance_type& MembraneType::
distance () const
{
  return this->distance_.get ();
}

MembraneType::distance_type& MembraneType::
distance ()
{
  return this->distance_.get ();
}

void MembraneType::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void MembraneType::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}

const MembraneType::brown_velocity_optional& MembraneType::
brown_velocity () const
{
  return this->brown_velocity_;
}

MembraneType::brown_velocity_optional& MembraneType::
brown_velocity ()
{
  return this->brown_velocity_;
}

void MembraneType::
brown_velocity (const brown_velocity_type& x)
{
  this->brown_velocity_.set (x);
}

void MembraneType::
brown_velocity (const brown_velocity_optional& x)
{
  this->brown_velocity_ = x;
}

MembraneType::brown_velocity_type MembraneType::
brown_velocity_default_value ()
{
  return brown_velocity_type (0.0);
}

const MembraneType::k_optional& MembraneType::
k () const
{
  return this->k_;
}

MembraneType::k_optional& MembraneType::
k ()
{
  return this->k_;
}

void MembraneType::
k (const k_type& x)
{
  this->k_.set (x);
}

void MembraneType::
k (const k_optional& x)
{
  this->k_ = x;
}

void MembraneType::
k (::std::unique_ptr< k_type > x)
{
  this->k_.set (std::move (x));
}

MembraneType::k_type MembraneType::
k_default_value ()
{
  return k_type (300.0);
}

const MembraneType::r0_optional& MembraneType::
r0 () const
{
  return this->r0_;
}

MembraneType::r0_optional& MembraneType::
r0 ()
{
  return this->r0_;
}

void MembraneType::
r0 (const r0_type& x)
{
  this->r0_.set (x);
}

void MembraneType::
r0 (const r0_optional& x)
{
  this->r0_ = x;
}

void MembraneType::
r0 (::std::unique_ptr< r0_type > x)
{
  this->r0_.set (std::move (x));
}

MembraneType::r0_type MembraneType::
r0_default_value ()
{
  return r0_type (2.2);
}

const MembraneType::external_force_sequence& MembraneType::
external_force () const
{
  return this->external_force_;
}

MembraneType::external_force_sequence& MembraneType::
external_force ()
{
  return this->external_force_;
}

void MembraneType::
external_force (const external_force_sequence& s)
{
  this->external_force_ = s;
}


// WallType
// 

const WallType::size_type& WallType::
size () const
{
  return this->size_.get ();
}

WallType::size_type& WallType::
size ()
{
  return this->size_.get ();
}

void WallType::
size (const size_type& x)
{
  this->size_.set (x);
}

void WallType::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const WallType::distance_type& WallType::
distance () const
{
  return this->distance_.get ();
}

WallType::distance_type& WallType::
distance ()
{
  return this->distance_.get ();
}

void WallType::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void WallType::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}


// SimulationObjects
// 

const SimulationObjects::particle_sequence& SimulationObjects::
particle () const
{
  return this->particle_;
}

SimulationObjects::particle_sequence& SimulationObjects::
particle ()
{
  return this->particle_;
}

void SimulationObjects::
particle (const particle_sequence& s)
{
  this->particle_ = s;
}

const SimulationObjects::cuboid_sequence& SimulationObjects::
cuboid () const
{
  return this->cuboid_;
}

SimulationObjects::cuboid_sequence& SimulationObjects::
cuboid ()
{
  return this->cuboid_;
}

void SimulationObjects::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}

const SimulationObjects::sphere_sequence& SimulationObjects::
sphere () const
{
  return this->sphere_;
}

SimulationObjects::sphere_sequence& SimulationObjects::
sphere ()
{
  return this->sphere_;
}

void SimulationObjects::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const SimulationObjects::membrane_sequence& SimulationObjects::
membrane () const
{
  return this->membrane_;
}

SimulationObjects::membrane_sequence& SimulationObjects::
membrane ()
{
  return this->membrane_;
}

void SimulationObjects::
membrane (const membrane_sequence& s)
{
  this->membrane_ = s;
}

const SimulationObjects::wall_sequence& SimulationObjects::
wall () const
{
  return this->wall_;
}

SimulationObjects::wall_sequence& SimulationObjects::
wall ()
{
  return this->wall_;
}

void SimulationObjects::
wall (const wall_sequence& s)
{
  this->wall_ = s;
}

const SimulationObjects::load_sequence& SimulationObjects::
load () const
{
  return this->load_;
}

SimulationObjects::load_sequence& SimulationObjects::
load ()
{
  return this->load_;
}

void SimulationObjects::
load (const load_sequence& s)
{
  this->load_ = s;
}


// BoundaryConditionType
// 

BoundaryConditionType::
BoundaryConditionType (value v)
: ::xml_schema::string (_xsd_BoundaryConditionType_literals_[v])
{
}

BoundaryConditionType::
BoundaryConditionType (const char* v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const BoundaryConditionType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

BoundaryConditionType& BoundaryConditionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_BoundaryConditionType_literals_[v]);

  return *this;
}


// BoundaryCondition3
// 

const BoundaryCondition3::left_optional& BoundaryCondition3::
left () const
{
  return this->left_;
}

BoundaryCondition3::left_optional& BoundaryCondition3::
left ()
{
  return this->left_;
}

void BoundaryCondition3::
left (const left_type& x)
{
  this->left_.set (x);
}

void BoundaryCondition3::
left (const left_optional& x)
{
  this->left_ = x;
}

void BoundaryCondition3::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const BoundaryCondition3::left_type& BoundaryCondition3::
left_default_value ()
{
  return left_default_value_;
}

const BoundaryCondition3::right_optional& BoundaryCondition3::
right () const
{
  return this->right_;
}

BoundaryCondition3::right_optional& BoundaryCondition3::
right ()
{
  return this->right_;
}

void BoundaryCondition3::
right (const right_type& x)
{
  this->right_.set (x);
}

void BoundaryCondition3::
right (const right_optional& x)
{
  this->right_ = x;
}

void BoundaryCondition3::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const BoundaryCondition3::right_type& BoundaryCondition3::
right_default_value ()
{
  return right_default_value_;
}

const BoundaryCondition3::down_optional& BoundaryCondition3::
down () const
{
  return this->down_;
}

BoundaryCondition3::down_optional& BoundaryCondition3::
down ()
{
  return this->down_;
}

void BoundaryCondition3::
down (const down_type& x)
{
  this->down_.set (x);
}

void BoundaryCondition3::
down (const down_optional& x)
{
  this->down_ = x;
}

void BoundaryCondition3::
down (::std::unique_ptr< down_type > x)
{
  this->down_.set (std::move (x));
}

const BoundaryCondition3::down_type& BoundaryCondition3::
down_default_value ()
{
  return down_default_value_;
}

const BoundaryCondition3::up_optional& BoundaryCondition3::
up () const
{
  return this->up_;
}

BoundaryCondition3::up_optional& BoundaryCondition3::
up ()
{
  return this->up_;
}

void BoundaryCondition3::
up (const up_type& x)
{
  this->up_.set (x);
}

void BoundaryCondition3::
up (const up_optional& x)
{
  this->up_ = x;
}

void BoundaryCondition3::
up (::std::unique_ptr< up_type > x)
{
  this->up_.set (std::move (x));
}

const BoundaryCondition3::up_type& BoundaryCondition3::
up_default_value ()
{
  return up_default_value_;
}

const BoundaryCondition3::back_optional& BoundaryCondition3::
back () const
{
  return this->back_;
}

BoundaryCondition3::back_optional& BoundaryCondition3::
back ()
{
  return this->back_;
}

void BoundaryCondition3::
back (const back_type& x)
{
  this->back_.set (x);
}

void BoundaryCondition3::
back (const back_optional& x)
{
  this->back_ = x;
}

void BoundaryCondition3::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}

const BoundaryCondition3::back_type& BoundaryCondition3::
back_default_value ()
{
  return back_default_value_;
}

const BoundaryCondition3::front_optional& BoundaryCondition3::
front () const
{
  return this->front_;
}

BoundaryCondition3::front_optional& BoundaryCondition3::
front ()
{
  return this->front_;
}

void BoundaryCondition3::
front (const front_type& x)
{
  this->front_.set (x);
}

void BoundaryCondition3::
front (const front_optional& x)
{
  this->front_ = x;
}

void BoundaryCondition3::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const BoundaryCondition3::front_type& BoundaryCondition3::
front_default_value ()
{
  return front_default_value_;
}


// ForceType
// 

ForceType::
ForceType (value v)
: ::xml_schema::string (_xsd_ForceType_literals_[v])
{
}

ForceType::
ForceType (const char* v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ForceType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ForceType& ForceType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ForceType_literals_[v]);

  return *this;
}


// OutputFormatType
// 

OutputFormatType::
OutputFormatType (value v)
: ::xml_schema::string (_xsd_OutputFormatType_literals_[v])
{
}

OutputFormatType::
OutputFormatType (const char* v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const OutputFormatType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

OutputFormatType& OutputFormatType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_OutputFormatType_literals_[v]);

  return *this;
}


// LinkedCellType
// 

const LinkedCellType::domain_size_type& LinkedCellType::
domain_size () const
{
  return this->domain_size_.get ();
}

LinkedCellType::domain_size_type& LinkedCellType::
domain_size ()
{
  return this->domain_size_.get ();
}

void LinkedCellType::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void LinkedCellType::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const LinkedCellType::cutoff_radius_type& LinkedCellType::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

LinkedCellType::cutoff_radius_type& LinkedCellType::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void LinkedCellType::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void LinkedCellType::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}

const LinkedCellType::boundary_condition_optional& LinkedCellType::
boundary_condition () const
{
  return this->boundary_condition_;
}

LinkedCellType::boundary_condition_optional& LinkedCellType::
boundary_condition ()
{
  return this->boundary_condition_;
}

void LinkedCellType::
boundary_condition (const boundary_condition_type& x)
{
  this->boundary_condition_.set (x);
}

void LinkedCellType::
boundary_condition (const boundary_condition_optional& x)
{
  this->boundary_condition_ = x;
}

void LinkedCellType::
boundary_condition (::std::unique_ptr< boundary_condition_type > x)
{
  this->boundary_condition_.set (std::move (x));
}

const LinkedCellType::strategy_optional& LinkedCellType::
strategy () const
{
  return this->strategy_;
}

LinkedCellType::strategy_optional& LinkedCellType::
strategy ()
{
  return this->strategy_;
}

void LinkedCellType::
strategy (const strategy_type& x)
{
  this->strategy_.set (x);
}

void LinkedCellType::
strategy (const strategy_optional& x)
{
  this->strategy_ = x;
}

void LinkedCellType::
strategy (::std::unique_ptr< strategy_type > x)
{
  this->strategy_.set (std::move (x));
}

LinkedCellType::strategy_type LinkedCellType::
strategy_default_value ()
{
  return strategy_type (0LL);
}


// ThermostatsType
// 

const ThermostatsType::initial_T_type& ThermostatsType::
initial_T () const
{
  return this->initial_T_.get ();
}

ThermostatsType::initial_T_type& ThermostatsType::
initial_T ()
{
  return this->initial_T_.get ();
}

void ThermostatsType::
initial_T (const initial_T_type& x)
{
  this->initial_T_.set (x);
}

void ThermostatsType::
initial_T (::std::unique_ptr< initial_T_type > x)
{
  this->initial_T_.set (std::move (x));
}

const ThermostatsType::target_T_optional& ThermostatsType::
target_T () const
{
  return this->target_T_;
}

ThermostatsType::target_T_optional& ThermostatsType::
target_T ()
{
  return this->target_T_;
}

void ThermostatsType::
target_T (const target_T_type& x)
{
  this->target_T_.set (x);
}

void ThermostatsType::
target_T (const target_T_optional& x)
{
  this->target_T_ = x;
}

void ThermostatsType::
target_T (::std::unique_ptr< target_T_type > x)
{
  this->target_T_.set (std::move (x));
}

const ThermostatsType::period_type& ThermostatsType::
period () const
{
  return this->period_.get ();
}

ThermostatsType::period_type& ThermostatsType::
period ()
{
  return this->period_.get ();
}

void ThermostatsType::
period (const period_type& x)
{
  this->period_.set (x);
}

const ThermostatsType::max_delta_optional& ThermostatsType::
max_delta () const
{
  return this->max_delta_;
}

ThermostatsType::max_delta_optional& ThermostatsType::
max_delta ()
{
  return this->max_delta_;
}

void ThermostatsType::
max_delta (const max_delta_type& x)
{
  this->max_delta_.set (x);
}

void ThermostatsType::
max_delta (const max_delta_optional& x)
{
  this->max_delta_ = x;
}

void ThermostatsType::
max_delta (::std::unique_ptr< max_delta_type > x)
{
  this->max_delta_.set (std::move (x));
}


// AxisType
// 

AxisType::
AxisType (value v)
: ::xml_schema::string (_xsd_AxisType_literals_[v])
{
}

AxisType::
AxisType (const char* v)
: ::xml_schema::string (v)
{
}

AxisType::
AxisType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

AxisType::
AxisType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

AxisType::
AxisType (const AxisType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

AxisType& AxisType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_AxisType_literals_[v]);

  return *this;
}


// StatisticsType
// 

const StatisticsType::output_type& StatisticsType::
output () const
{
  return this->output_.get ();
}

StatisticsType::output_type& StatisticsType::
output ()
{
  return this->output_.get ();
}

void StatisticsType::
output (const output_type& x)
{
  this->output_.set (x);
}

void StatisticsType::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const StatisticsType::period_type& StatisticsType::
period () const
{
  return this->period_.get ();
}

StatisticsType::period_type& StatisticsType::
period ()
{
  return this->period_.get ();
}

void StatisticsType::
period (const period_type& x)
{
  this->period_.set (x);
}

const StatisticsType::from_type& StatisticsType::
from () const
{
  return this->from_.get ();
}

StatisticsType::from_type& StatisticsType::
from ()
{
  return this->from_.get ();
}

void StatisticsType::
from (const from_type& x)
{
  this->from_.set (x);
}

const StatisticsType::to_type& StatisticsType::
to () const
{
  return this->to_.get ();
}

StatisticsType::to_type& StatisticsType::
to ()
{
  return this->to_.get ();
}

void StatisticsType::
to (const to_type& x)
{
  this->to_.set (x);
}

const StatisticsType::num_bins_type& StatisticsType::
num_bins () const
{
  return this->num_bins_.get ();
}

StatisticsType::num_bins_type& StatisticsType::
num_bins ()
{
  return this->num_bins_.get ();
}

void StatisticsType::
num_bins (const num_bins_type& x)
{
  this->num_bins_.set (x);
}

const StatisticsType::profile_axis_optional& StatisticsType::
profile_axis () const
{
  return this->profile_axis_;
}

StatisticsType::profile_axis_optional& StatisticsType::
profile_axis ()
{
  return this->profile_axis_;
}

void StatisticsType::
profile_axis (const profile_axis_type& x)
{
  this->profile_axis_.set (x);
}

void StatisticsType::
profile_axis (const profile_axis_optional& x)
{
  this->profile_axis_ = x;
}

void StatisticsType::
profile_axis (::std::unique_ptr< profile_axis_type > x)
{
  this->profile_axis_.set (std::move (x));
}

const StatisticsType::profile_axis_type& StatisticsType::
profile_axis_default_value ()
{
  return profile_axis_default_value_;
}

const StatisticsType::velocity_axis_optional& StatisticsType::
velocity_axis () const
{
  return this->velocity_axis_;
}

StatisticsType::velocity_axis_optional& StatisticsType::
velocity_axis ()
{
  return this->velocity_axis_;
}

void StatisticsType::
velocity_axis (const velocity_axis_type& x)
{
  this->velocity_axis_.set (x);
}

void StatisticsType::
velocity_axis (const velocity_axis_optional& x)
{
  this->velocity_axis_ = x;
}

void StatisticsType::
velocity_axis (::std::unique_ptr< velocity_axis_type > x)
{
  this->velocity_axis_.set (std::move (x));
}

const StatisticsType::velocity_axis_type& StatisticsType::
velocity_axis_default_value ()
{
  return velocity_axis_default_value_;
}


// SimulationParameters
// 

const SimulationParameters::start_time_optional& SimulationParameters::
start_time () const
{
  return this->start_time_;
}

SimulationParameters::start_time_optional& SimulationParameters::
start_time ()
{
  return this->start_time_;
}

void SimulationParameters::
start_time (const start_time_type& x)
{
  this->start_time_.set (x);
}

void SimulationParameters::
start_time (const start_time_optional& x)
{
  this->start_time_ = x;
}

SimulationParameters::start_time_type SimulationParameters::
start_time_default_value ()
{
  return start_time_type (0.0);
}

const SimulationParameters::end_time_optional& SimulationParameters::
end_time () const
{
  return this->end_time_;
}

SimulationParameters::end_time_optional& SimulationParameters::
end_time ()
{
  return this->end_time_;
}

void SimulationParameters::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

void SimulationParameters::
end_time (const end_time_optional& x)
{
  this->end_time_ = x;
}

void SimulationParameters::
end_time (::std::unique_ptr< end_time_type > x)
{
  this->end_time_.set (std::move (x));
}

SimulationParameters::end_time_type SimulationParameters::
end_time_default_value ()
{
  return end_time_type (5.0);
}

const SimulationParameters::delta_t_optional& SimulationParameters::
delta_t () const
{
  return this->delta_t_;
}

SimulationParameters::delta_t_optional& SimulationParameters::
delta_t ()
{
  return this->delta_t_;
}

void SimulationParameters::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

void SimulationParameters::
delta_t (const delta_t_optional& x)
{
  this->delta_t_ = x;
}

void SimulationParameters::
delta_t (::std::unique_ptr< delta_t_type > x)
{
  this->delta_t_.set (std::move (x));
}

SimulationParameters::delta_t_type SimulationParameters::
delta_t_default_value ()
{
  return delta_t_type (.0002);
}

const SimulationParameters::frequency_optional& SimulationParameters::
frequency () const
{
  return this->frequency_;
}

SimulationParameters::frequency_optional& SimulationParameters::
frequency ()
{
  return this->frequency_;
}

void SimulationParameters::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}

void SimulationParameters::
frequency (const frequency_optional& x)
{
  this->frequency_ = x;
}

SimulationParameters::frequency_type SimulationParameters::
frequency_default_value ()
{
  return frequency_type (10ULL);
}

const SimulationParameters::output_optional& SimulationParameters::
output () const
{
  return this->output_;
}

SimulationParameters::output_optional& SimulationParameters::
output ()
{
  return this->output_;
}

void SimulationParameters::
output (const output_type& x)
{
  this->output_.set (x);
}

void SimulationParameters::
output (const output_optional& x)
{
  this->output_ = x;
}

void SimulationParameters::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const SimulationParameters::output_type& SimulationParameters::
output_default_value ()
{
  return output_default_value_;
}

const SimulationParameters::format_optional& SimulationParameters::
format () const
{
  return this->format_;
}

SimulationParameters::format_optional& SimulationParameters::
format ()
{
  return this->format_;
}

void SimulationParameters::
format (const format_type& x)
{
  this->format_.set (x);
}

void SimulationParameters::
format (const format_optional& x)
{
  this->format_ = x;
}

void SimulationParameters::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}

const SimulationParameters::format_type& SimulationParameters::
format_default_value ()
{
  return format_default_value_;
}

const SimulationParameters::force_optional& SimulationParameters::
force () const
{
  return this->force_;
}

SimulationParameters::force_optional& SimulationParameters::
force ()
{
  return this->force_;
}

void SimulationParameters::
force (const force_type& x)
{
  this->force_.set (x);
}

void SimulationParameters::
force (const force_optional& x)
{
  this->force_ = x;
}

void SimulationParameters::
force (::std::unique_ptr< force_type > x)
{
  this->force_.set (std::move (x));
}

const SimulationParameters::force_type& SimulationParameters::
force_default_value ()
{
  return force_default_value_;
}

const SimulationParameters::g_optional& SimulationParameters::
g () const
{
  return this->g_;
}

SimulationParameters::g_optional& SimulationParameters::
g ()
{
  return this->g_;
}

void SimulationParameters::
g (const g_type& x)
{
  this->g_.set (x);
}

void SimulationParameters::
g (const g_optional& x)
{
  this->g_ = x;
}

void SimulationParameters::
g (::std::unique_ptr< g_type > x)
{
  this->g_.set (std::move (x));
}

const SimulationParameters::dimension_optional& SimulationParameters::
dimension () const
{
  return this->dimension_;
}

SimulationParameters::dimension_optional& SimulationParameters::
dimension ()
{
  return this->dimension_;
}

void SimulationParameters::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void SimulationParameters::
dimension (const dimension_optional& x)
{
  this->dimension_ = x;
}

void SimulationParameters::
dimension (::std::unique_ptr< dimension_type > x)
{
  this->dimension_.set (std::move (x));
}

SimulationParameters::dimension_type SimulationParameters::
dimension_default_value ()
{
  return dimension_type (2ULL);
}

const SimulationParameters::thermostat_optional& SimulationParameters::
thermostat () const
{
  return this->thermostat_;
}

SimulationParameters::thermostat_optional& SimulationParameters::
thermostat ()
{
  return this->thermostat_;
}

void SimulationParameters::
thermostat (const thermostat_type& x)
{
  this->thermostat_.set (x);
}

void SimulationParameters::
thermostat (const thermostat_optional& x)
{
  this->thermostat_ = x;
}

void SimulationParameters::
thermostat (::std::unique_ptr< thermostat_type > x)
{
  this->thermostat_.set (std::move (x));
}

const SimulationParameters::linked_cell_optional& SimulationParameters::
linked_cell () const
{
  return this->linked_cell_;
}

SimulationParameters::linked_cell_optional& SimulationParameters::
linked_cell ()
{
  return this->linked_cell_;
}

void SimulationParameters::
linked_cell (const linked_cell_type& x)
{
  this->linked_cell_.set (x);
}

void SimulationParameters::
linked_cell (const linked_cell_optional& x)
{
  this->linked_cell_ = x;
}

void SimulationParameters::
linked_cell (::std::unique_ptr< linked_cell_type > x)
{
  this->linked_cell_.set (std::move (x));
}

const SimulationParameters::store_optional& SimulationParameters::
store () const
{
  return this->store_;
}

SimulationParameters::store_optional& SimulationParameters::
store ()
{
  return this->store_;
}

void SimulationParameters::
store (const store_type& x)
{
  this->store_.set (x);
}

void SimulationParameters::
store (const store_optional& x)
{
  this->store_ = x;
}

void SimulationParameters::
store (::std::unique_ptr< store_type > x)
{
  this->store_.set (std::move (x));
}

const SimulationParameters::statistics_optional& SimulationParameters::
statistics () const
{
  return this->statistics_;
}

SimulationParameters::statistics_optional& SimulationParameters::
statistics ()
{
  return this->statistics_;
}

void SimulationParameters::
statistics (const statistics_type& x)
{
  this->statistics_.set (x);
}

void SimulationParameters::
statistics (const statistics_optional& x)
{
  this->statistics_ = x;
}

void SimulationParameters::
statistics (::std::unique_ptr< statistics_type > x)
{
  this->statistics_.set (std::move (x));
}


// InputData
// 

const InputData::objects_type& InputData::
objects () const
{
  return this->objects_.get ();
}

InputData::objects_type& InputData::
objects ()
{
  return this->objects_.get ();
}

void InputData::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void InputData::
objects (::std::unique_ptr< objects_type > x)
{
  this->objects_.set (std::move (x));
}

const InputData::parameters_type& InputData::
parameters () const
{
  return this->parameters_.get ();
}

InputData::parameters_type& InputData::
parameters ()
{
  return this->parameters_.get ();
}

void InputData::
parameters (const parameters_type& x)
{
  this->parameters_.set (x);
}

void InputData::
parameters (::std::unique_ptr< parameters_type > x)
{
  this->parameters_.set (std::move (x));
}


// strategy
// 

strategy::
strategy (::xml_schema::integer v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (v)
{
}

strategy::
strategy (const strategy& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (v, f, c)
{
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Dimension
//

Dimension::
Dimension (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
{
}

Dimension::
Dimension (const Dimension& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

Dimension::
Dimension (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

Dimension::
Dimension (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

Dimension::
Dimension (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

Dimension* Dimension::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Dimension (*this, f, c);
}

Dimension::
~Dimension ()
{
}

// PositiveDouble
//

PositiveDouble::
PositiveDouble (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

PositiveDouble::
PositiveDouble (const PositiveDouble& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

PositiveDouble* PositiveDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDouble (*this, f, c);
}

PositiveDouble::
~PositiveDouble ()
{
}

// DoubleVector3
//

DoubleVector3::
DoubleVector3 (const x_type& x,
               const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

DoubleVector3::
DoubleVector3 (const DoubleVector3& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

DoubleVector3::
DoubleVector3 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DoubleVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!this->z_)
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

DoubleVector3* DoubleVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoubleVector3 (*this, f, c);
}

DoubleVector3& DoubleVector3::
operator= (const DoubleVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

DoubleVector3::
~DoubleVector3 ()
{
}

// OptionalDoubleVector3
//

OptionalDoubleVector3::
OptionalDoubleVector3 ()
: ::xml_schema::type (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

OptionalDoubleVector3::
OptionalDoubleVector3 (const OptionalDoubleVector3& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

OptionalDoubleVector3::
OptionalDoubleVector3 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OptionalDoubleVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!this->x_)
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!this->y_)
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!this->z_)
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

OptionalDoubleVector3* OptionalDoubleVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OptionalDoubleVector3 (*this, f, c);
}

OptionalDoubleVector3& OptionalDoubleVector3::
operator= (const OptionalDoubleVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

OptionalDoubleVector3::
~OptionalDoubleVector3 ()
{
}

// PositiveIntVector2
//

PositiveIntVector2::
PositiveIntVector2 (const x_type& x,
                    const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this)
{
}

PositiveIntVector2::
PositiveIntVector2 (const PositiveIntVector2& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

PositiveIntVector2::
PositiveIntVector2 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PositiveIntVector2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

PositiveIntVector2* PositiveIntVector2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveIntVector2 (*this, f, c);
}

PositiveIntVector2& PositiveIntVector2::
operator= (const PositiveIntVector2& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
  }

  return *this;
}

PositiveIntVector2::
~PositiveIntVector2 ()
{
}

// PositiveIntVector3
//

PositiveIntVector3::
PositiveIntVector3 (const x_type& x,
                    const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

PositiveIntVector3::
PositiveIntVector3 (const PositiveIntVector3& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

PositiveIntVector3::
PositiveIntVector3 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PositiveIntVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!this->z_)
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

PositiveIntVector3* PositiveIntVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveIntVector3 (*this, f, c);
}

PositiveIntVector3& PositiveIntVector3::
operator= (const PositiveIntVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

PositiveIntVector3::
~PositiveIntVector3 ()
{
}

// PositiveDoubleVector3
//

PositiveDoubleVector3::
PositiveDoubleVector3 (const x_type& x,
                       const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

PositiveDoubleVector3::
PositiveDoubleVector3 (const PositiveDoubleVector3& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

PositiveDoubleVector3::
PositiveDoubleVector3 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PositiveDoubleVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< x_type > r (
        x_traits::create (i, f, this));

      if (!x_.present ())
      {
        this->x_.set (::std::move (r));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< y_type > r (
        y_traits::create (i, f, this));

      if (!y_.present ())
      {
        this->y_.set (::std::move (r));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< z_type > r (
        z_traits::create (i, f, this));

      if (!this->z_)
      {
        this->z_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

PositiveDoubleVector3* PositiveDoubleVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDoubleVector3 (*this, f, c);
}

PositiveDoubleVector3& PositiveDoubleVector3::
operator= (const PositiveDoubleVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

PositiveDoubleVector3::
~PositiveDoubleVector3 ()
{
}

// ParticleType
//

ParticleType::
ParticleType (const position_type& position,
              const mass_type& mass)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (this),
  mass_ (mass, this),
  type_ (this),
  epsilon_ (this),
  sigma_ (this)
{
}

ParticleType::
ParticleType (::std::unique_ptr< position_type > position,
              const mass_type& mass)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (this),
  mass_ (mass, this),
  type_ (this),
  epsilon_ (this),
  sigma_ (this)
{
}

ParticleType::
ParticleType (const ParticleType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  type_ (x.type_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this)
{
}

ParticleType::
ParticleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  mass_ (this),
  type_ (this),
  epsilon_ (this),
  sigma_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParticleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!this->velocity_)
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!this->type_)
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!this->epsilon_)
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!this->sigma_)
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

ParticleType* ParticleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParticleType (*this, f, c);
}

ParticleType& ParticleType::
operator= (const ParticleType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->type_ = x.type_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
  }

  return *this;
}

ParticleType::
~ParticleType ()
{
}

// CuboidType
//

CuboidType::
CuboidType (const position_type& position,
            const mass_type& mass,
            const size_type& size,
            const distance_type& distance)
: ::ParticleType (position,
                  mass),
  size_ (size, this),
  distance_ (distance, this),
  brown_velocity_ (this)
{
}

CuboidType::
CuboidType (::std::unique_ptr< position_type > position,
            const mass_type& mass,
            ::std::unique_ptr< size_type > size,
            const distance_type& distance)
: ::ParticleType (std::move (position),
                  mass),
  size_ (std::move (size), this),
  distance_ (distance, this),
  brown_velocity_ (this)
{
}

CuboidType::
CuboidType (const CuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::ParticleType (x, f, c),
  size_ (x.size_, f, this),
  distance_ (x.distance_, f, this),
  brown_velocity_ (x.brown_velocity_, f, this)
{
}

CuboidType::
CuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::ParticleType (e, f | ::xml_schema::flags::base, c),
  size_ (this),
  distance_ (this),
  brown_velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::ParticleType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // size
    //
    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< distance_type > r (
        distance_traits::create (i, f, this));

      if (!distance_.present ())
      {
        this->distance_.set (::std::move (r));
        continue;
      }
    }

    // brown_velocity
    //
    if (n.name () == "brown_velocity" && n.namespace_ ().empty ())
    {
      if (!this->brown_velocity_)
      {
        this->brown_velocity_.set (brown_velocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }
}

CuboidType* CuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CuboidType (*this, f, c);
}

CuboidType& CuboidType::
operator= (const CuboidType& x)
{
  if (this != &x)
  {
    static_cast< ::ParticleType& > (*this) = x;
    this->size_ = x.size_;
    this->distance_ = x.distance_;
    this->brown_velocity_ = x.brown_velocity_;
  }

  return *this;
}

CuboidType::
~CuboidType ()
{
}

// SphereType
//

SphereType::
SphereType (const position_type& position,
            const mass_type& mass,
            const radius_type& radius,
            const distance_type& distance)
: ::ParticleType (position,
                  mass),
  radius_ (radius, this),
  distance_ (distance, this),
  brown_velocity_ (this)
{
}

SphereType::
SphereType (::std::unique_ptr< position_type > position,
            const mass_type& mass,
            const radius_type& radius,
            const distance_type& distance)
: ::ParticleType (std::move (position),
                  mass),
  radius_ (radius, this),
  distance_ (distance, this),
  brown_velocity_ (this)
{
}

SphereType::
SphereType (const SphereType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::ParticleType (x, f, c),
  radius_ (x.radius_, f, this),
  distance_ (x.distance_, f, this),
  brown_velocity_ (x.brown_velocity_, f, this)
{
}

SphereType::
SphereType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::ParticleType (e, f | ::xml_schema::flags::base, c),
  radius_ (this),
  distance_ (this),
  brown_velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SphereType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::ParticleType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< distance_type > r (
        distance_traits::create (i, f, this));

      if (!distance_.present ())
      {
        this->distance_.set (::std::move (r));
        continue;
      }
    }

    // brown_velocity
    //
    if (n.name () == "brown_velocity" && n.namespace_ ().empty ())
    {
      if (!this->brown_velocity_)
      {
        this->brown_velocity_.set (brown_velocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }
}

SphereType* SphereType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SphereType (*this, f, c);
}

SphereType& SphereType::
operator= (const SphereType& x)
{
  if (this != &x)
  {
    static_cast< ::ParticleType& > (*this) = x;
    this->radius_ = x.radius_;
    this->distance_ = x.distance_;
    this->brown_velocity_ = x.brown_velocity_;
  }

  return *this;
}

SphereType::
~SphereType ()
{
}

// ExternalForceType
//

ExternalForceType::
ExternalForceType (const force_type& force,
                   const until_type& until)
: ::xml_schema::type (),
  index_ (this),
  force_ (force, this),
  until_ (until, this)
{
}

ExternalForceType::
ExternalForceType (::std::unique_ptr< force_type > force,
                   const until_type& until)
: ::xml_schema::type (),
  index_ (this),
  force_ (std::move (force), this),
  until_ (until, this)
{
}

ExternalForceType::
ExternalForceType (const ExternalForceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  index_ (x.index_, f, this),
  force_ (x.force_, f, this),
  until_ (x.until_, f, this)
{
}

ExternalForceType::
ExternalForceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  index_ (this),
  force_ (this),
  until_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ExternalForceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // index
    //
    if (n.name () == "index" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< index_type > r (
        index_traits::create (i, f, this));

      this->index_.push_back (::std::move (r));
      continue;
    }

    // force
    //
    if (n.name () == "force" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< force_type > r (
        force_traits::create (i, f, this));

      if (!force_.present ())
      {
        this->force_.set (::std::move (r));
        continue;
      }
    }

    // until
    //
    if (n.name () == "until" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< until_type > r (
        until_traits::create (i, f, this));

      if (!until_.present ())
      {
        this->until_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "force",
      "");
  }

  if (!until_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "until",
      "");
  }
}

ExternalForceType* ExternalForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ExternalForceType (*this, f, c);
}

ExternalForceType& ExternalForceType::
operator= (const ExternalForceType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->index_ = x.index_;
    this->force_ = x.force_;
    this->until_ = x.until_;
  }

  return *this;
}

ExternalForceType::
~ExternalForceType ()
{
}

// MembraneType
//

MembraneType::
MembraneType (const position_type& position,
              const mass_type& mass,
              const size_type& size,
              const distance_type& distance)
: ::ParticleType (position,
                  mass),
  size_ (size, this),
  distance_ (distance, this),
  brown_velocity_ (this),
  k_ (this),
  r0_ (this),
  external_force_ (this)
{
}

MembraneType::
MembraneType (::std::unique_ptr< position_type > position,
              const mass_type& mass,
              ::std::unique_ptr< size_type > size,
              const distance_type& distance)
: ::ParticleType (std::move (position),
                  mass),
  size_ (std::move (size), this),
  distance_ (distance, this),
  brown_velocity_ (this),
  k_ (this),
  r0_ (this),
  external_force_ (this)
{
}

MembraneType::
MembraneType (const MembraneType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::ParticleType (x, f, c),
  size_ (x.size_, f, this),
  distance_ (x.distance_, f, this),
  brown_velocity_ (x.brown_velocity_, f, this),
  k_ (x.k_, f, this),
  r0_ (x.r0_, f, this),
  external_force_ (x.external_force_, f, this)
{
}

MembraneType::
MembraneType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::ParticleType (e, f | ::xml_schema::flags::base, c),
  size_ (this),
  distance_ (this),
  brown_velocity_ (this),
  k_ (this),
  r0_ (this),
  external_force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MembraneType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::ParticleType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // size
    //
    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< distance_type > r (
        distance_traits::create (i, f, this));

      if (!distance_.present ())
      {
        this->distance_.set (::std::move (r));
        continue;
      }
    }

    // brown_velocity
    //
    if (n.name () == "brown_velocity" && n.namespace_ ().empty ())
    {
      if (!this->brown_velocity_)
      {
        this->brown_velocity_.set (brown_velocity_traits::create (i, f, this));
        continue;
      }
    }

    // k
    //
    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< k_type > r (
        k_traits::create (i, f, this));

      if (!this->k_)
      {
        this->k_.set (::std::move (r));
        continue;
      }
    }

    // r0
    //
    if (n.name () == "r0" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< r0_type > r (
        r0_traits::create (i, f, this));

      if (!this->r0_)
      {
        this->r0_.set (::std::move (r));
        continue;
      }
    }

    // external_force
    //
    if (n.name () == "external_force" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< external_force_type > r (
        external_force_traits::create (i, f, this));

      this->external_force_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }
}

MembraneType* MembraneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MembraneType (*this, f, c);
}

MembraneType& MembraneType::
operator= (const MembraneType& x)
{
  if (this != &x)
  {
    static_cast< ::ParticleType& > (*this) = x;
    this->size_ = x.size_;
    this->distance_ = x.distance_;
    this->brown_velocity_ = x.brown_velocity_;
    this->k_ = x.k_;
    this->r0_ = x.r0_;
    this->external_force_ = x.external_force_;
  }

  return *this;
}

MembraneType::
~MembraneType ()
{
}

// WallType
//

WallType::
WallType (const position_type& position,
          const mass_type& mass,
          const size_type& size,
          const distance_type& distance)
: ::ParticleType (position,
                  mass),
  size_ (size, this),
  distance_ (distance, this)
{
}

WallType::
WallType (::std::unique_ptr< position_type > position,
          const mass_type& mass,
          ::std::unique_ptr< size_type > size,
          const distance_type& distance)
: ::ParticleType (std::move (position),
                  mass),
  size_ (std::move (size), this),
  distance_ (distance, this)
{
}

WallType::
WallType (const WallType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::ParticleType (x, f, c),
  size_ (x.size_, f, this),
  distance_ (x.distance_, f, this)
{
}

WallType::
WallType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::ParticleType (e, f | ::xml_schema::flags::base, c),
  size_ (this),
  distance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void WallType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::ParticleType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // size
    //
    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< distance_type > r (
        distance_traits::create (i, f, this));

      if (!distance_.present ())
      {
        this->distance_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }
}

WallType* WallType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class WallType (*this, f, c);
}

WallType& WallType::
operator= (const WallType& x)
{
  if (this != &x)
  {
    static_cast< ::ParticleType& > (*this) = x;
    this->size_ = x.size_;
    this->distance_ = x.distance_;
  }

  return *this;
}

WallType::
~WallType ()
{
}

// SimulationObjects
//

SimulationObjects::
SimulationObjects ()
: ::xml_schema::type (),
  particle_ (this),
  cuboid_ (this),
  sphere_ (this),
  membrane_ (this),
  wall_ (this),
  load_ (this)
{
}

SimulationObjects::
SimulationObjects (const SimulationObjects& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_ (x.particle_, f, this),
  cuboid_ (x.cuboid_, f, this),
  sphere_ (x.sphere_, f, this),
  membrane_ (x.membrane_, f, this),
  wall_ (x.wall_, f, this),
  load_ (x.load_, f, this)
{
}

SimulationObjects::
SimulationObjects (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_ (this),
  cuboid_ (this),
  sphere_ (this),
  membrane_ (this),
  wall_ (this),
  load_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SimulationObjects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle
    //
    if (n.name () == "particle" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_type > r (
        particle_traits::create (i, f, this));

      this->particle_.push_back (::std::move (r));
      continue;
    }

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (::std::move (r));
      continue;
    }

    // membrane
    //
    if (n.name () == "membrane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< membrane_type > r (
        membrane_traits::create (i, f, this));

      this->membrane_.push_back (::std::move (r));
      continue;
    }

    // wall
    //
    if (n.name () == "wall" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< wall_type > r (
        wall_traits::create (i, f, this));

      this->wall_.push_back (::std::move (r));
      continue;
    }

    // load
    //
    if (n.name () == "load" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< load_type > r (
        load_traits::create (i, f, this));

      this->load_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

SimulationObjects* SimulationObjects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimulationObjects (*this, f, c);
}

SimulationObjects& SimulationObjects::
operator= (const SimulationObjects& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particle_ = x.particle_;
    this->cuboid_ = x.cuboid_;
    this->sphere_ = x.sphere_;
    this->membrane_ = x.membrane_;
    this->wall_ = x.wall_;
    this->load_ = x.load_;
  }

  return *this;
}

SimulationObjects::
~SimulationObjects ()
{
}

// BoundaryConditionType
//

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType* BoundaryConditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryConditionType (*this, f, c);
}

BoundaryConditionType::value BoundaryConditionType::
_xsd_BoundaryConditionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BoundaryConditionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_BoundaryConditionType_indexes_,
                    _xsd_BoundaryConditionType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_BoundaryConditionType_indexes_ + 3 || _xsd_BoundaryConditionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const BoundaryConditionType::
_xsd_BoundaryConditionType_literals_[3] =
{
  "outflow",
  "reflect",
  "periodic"
};

const BoundaryConditionType::value BoundaryConditionType::
_xsd_BoundaryConditionType_indexes_[3] =
{
  ::BoundaryConditionType::outflow,
  ::BoundaryConditionType::periodic,
  ::BoundaryConditionType::reflect
};

// BoundaryCondition3
//

const BoundaryCondition3::left_type BoundaryCondition3::left_default_value_ (
  "outflow");

const BoundaryCondition3::right_type BoundaryCondition3::right_default_value_ (
  "outflow");

const BoundaryCondition3::down_type BoundaryCondition3::down_default_value_ (
  "outflow");

const BoundaryCondition3::up_type BoundaryCondition3::up_default_value_ (
  "outflow");

const BoundaryCondition3::back_type BoundaryCondition3::back_default_value_ (
  "outflow");

const BoundaryCondition3::front_type BoundaryCondition3::front_default_value_ (
  "outflow");

BoundaryCondition3::
BoundaryCondition3 ()
: ::xml_schema::type (),
  left_ (this),
  right_ (this),
  down_ (this),
  up_ (this),
  back_ (this),
  front_ (this)
{
}

BoundaryCondition3::
BoundaryCondition3 (const BoundaryCondition3& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this),
  down_ (x.down_, f, this),
  up_ (x.up_, f, this),
  back_ (x.back_, f, this),
  front_ (x.front_, f, this)
{
}

BoundaryCondition3::
BoundaryCondition3 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  right_ (this),
  down_ (this),
  up_ (this),
  back_ (this),
  front_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BoundaryCondition3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!this->left_)
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!this->right_)
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // down
    //
    if (n.name () == "down" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< down_type > r (
        down_traits::create (i, f, this));

      if (!this->down_)
      {
        this->down_.set (::std::move (r));
        continue;
      }
    }

    // up
    //
    if (n.name () == "up" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< up_type > r (
        up_traits::create (i, f, this));

      if (!this->up_)
      {
        this->up_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!this->back_)
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!this->front_)
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

BoundaryCondition3* BoundaryCondition3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryCondition3 (*this, f, c);
}

BoundaryCondition3& BoundaryCondition3::
operator= (const BoundaryCondition3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->right_ = x.right_;
    this->down_ = x.down_;
    this->up_ = x.up_;
    this->back_ = x.back_;
    this->front_ = x.front_;
  }

  return *this;
}

BoundaryCondition3::
~BoundaryCondition3 ()
{
}

// ForceType
//

ForceType::
ForceType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType* ForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceType (*this, f, c);
}

ForceType::value ForceType::
_xsd_ForceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceType_indexes_,
                    _xsd_ForceType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ForceType_indexes_ + 3 || _xsd_ForceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceType::
_xsd_ForceType_literals_[3] =
{
  "gravitation",
  "Lennard-Jones",
  "membrane"
};

const ForceType::value ForceType::
_xsd_ForceType_indexes_[3] =
{
  ::ForceType::Lennard_Jones,
  ::ForceType::gravitation,
  ::ForceType::membrane
};

// OutputFormatType
//

OutputFormatType::
OutputFormatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType::
OutputFormatType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType::
OutputFormatType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType* OutputFormatType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OutputFormatType (*this, f, c);
}

OutputFormatType::value OutputFormatType::
_xsd_OutputFormatType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OutputFormatType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_OutputFormatType_indexes_,
                    _xsd_OutputFormatType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_OutputFormatType_indexes_ + 2 || _xsd_OutputFormatType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const OutputFormatType::
_xsd_OutputFormatType_literals_[2] =
{
  "vtu",
  "xyz"
};

const OutputFormatType::value OutputFormatType::
_xsd_OutputFormatType_indexes_[2] =
{
  ::OutputFormatType::vtu,
  ::OutputFormatType::xyz
};

// LinkedCellType
//

LinkedCellType::
LinkedCellType (const domain_size_type& domain_size,
                const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_condition_ (this),
  strategy_ (this)
{
}

LinkedCellType::
LinkedCellType (::std::unique_ptr< domain_size_type > domain_size,
                const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_condition_ (this),
  strategy_ (this)
{
}

LinkedCellType::
LinkedCellType (const LinkedCellType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  boundary_condition_ (x.boundary_condition_, f, this),
  strategy_ (x.strategy_, f, this)
{
}

LinkedCellType::
LinkedCellType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  cutoff_radius_ (this),
  boundary_condition_ (this),
  strategy_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LinkedCellType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cutoff_radius_type > r (
        cutoff_radius_traits::create (i, f, this));

      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (::std::move (r));
        continue;
      }
    }

    // boundary_condition
    //
    if (n.name () == "boundary_condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_condition_type > r (
        boundary_condition_traits::create (i, f, this));

      if (!this->boundary_condition_)
      {
        this->boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // strategy
    //
    if (n.name () == "strategy" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< strategy_type > r (
        strategy_traits::create (i, f, this));

      if (!this->strategy_)
      {
        this->strategy_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }
}

LinkedCellType* LinkedCellType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LinkedCellType (*this, f, c);
}

LinkedCellType& LinkedCellType::
operator= (const LinkedCellType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->cutoff_radius_ = x.cutoff_radius_;
    this->boundary_condition_ = x.boundary_condition_;
    this->strategy_ = x.strategy_;
  }

  return *this;
}

LinkedCellType::
~LinkedCellType ()
{
}

// ThermostatsType
//

ThermostatsType::
ThermostatsType (const initial_T_type& initial_T,
                 const period_type& period)
: ::xml_schema::type (),
  initial_T_ (initial_T, this),
  target_T_ (this),
  period_ (period, this),
  max_delta_ (this)
{
}

ThermostatsType::
ThermostatsType (const ThermostatsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  initial_T_ (x.initial_T_, f, this),
  target_T_ (x.target_T_, f, this),
  period_ (x.period_, f, this),
  max_delta_ (x.max_delta_, f, this)
{
}

ThermostatsType::
ThermostatsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  initial_T_ (this),
  target_T_ (this),
  period_ (this),
  max_delta_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ThermostatsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // initial_T
    //
    if (n.name () == "initial_T" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< initial_T_type > r (
        initial_T_traits::create (i, f, this));

      if (!initial_T_.present ())
      {
        this->initial_T_.set (::std::move (r));
        continue;
      }
    }

    // target_T
    //
    if (n.name () == "target_T" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< target_T_type > r (
        target_T_traits::create (i, f, this));

      if (!this->target_T_)
      {
        this->target_T_.set (::std::move (r));
        continue;
      }
    }

    // period
    //
    if (n.name () == "period" && n.namespace_ ().empty ())
    {
      if (!period_.present ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    // max_delta
    //
    if (n.name () == "max_delta" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< max_delta_type > r (
        max_delta_traits::create (i, f, this));

      if (!this->max_delta_)
      {
        this->max_delta_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!initial_T_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_T",
      "");
  }

  if (!period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "period",
      "");
  }
}

ThermostatsType* ThermostatsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ThermostatsType (*this, f, c);
}

ThermostatsType& ThermostatsType::
operator= (const ThermostatsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->initial_T_ = x.initial_T_;
    this->target_T_ = x.target_T_;
    this->period_ = x.period_;
    this->max_delta_ = x.max_delta_;
  }

  return *this;
}

ThermostatsType::
~ThermostatsType ()
{
}

// AxisType
//

AxisType::
AxisType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_AxisType_convert ();
}

AxisType::
AxisType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_AxisType_convert ();
}

AxisType::
AxisType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_AxisType_convert ();
}

AxisType* AxisType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AxisType (*this, f, c);
}

AxisType::value AxisType::
_xsd_AxisType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AxisType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_AxisType_indexes_,
                    _xsd_AxisType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_AxisType_indexes_ + 3 || _xsd_AxisType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const AxisType::
_xsd_AxisType_literals_[3] =
{
  "x",
  "y",
  "z"
};

const AxisType::value AxisType::
_xsd_AxisType_indexes_[3] =
{
  ::AxisType::x,
  ::AxisType::y,
  ::AxisType::z
};

// StatisticsType
//

const StatisticsType::profile_axis_type StatisticsType::profile_axis_default_value_ (
  "x");

const StatisticsType::velocity_axis_type StatisticsType::velocity_axis_default_value_ (
  "y");

StatisticsType::
StatisticsType (const output_type& output,
                const period_type& period,
                const from_type& from,
                const to_type& to,
                const num_bins_type& num_bins)
: ::xml_schema::type (),
  output_ (output, this),
  period_ (period, this),
  from_ (from, this),
  to_ (to, this),
  num_bins_ (num_bins, this),
  profile_axis_ (this),
  velocity_axis_ (this)
{
}

StatisticsType::
StatisticsType (const StatisticsType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  output_ (x.output_, f, this),
  period_ (x.period_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this),
  num_bins_ (x.num_bins_, f, this),
  profile_axis_ (x.profile_axis_, f, this),
  velocity_axis_ (x.velocity_axis_, f, this)
{
}

StatisticsType::
StatisticsType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  output_ (this),
  period_ (this),
  from_ (this),
  to_ (this),
  num_bins_ (this),
  profile_axis_ (this),
  velocity_axis_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void StatisticsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (::std::move (r));
        continue;
      }
    }

    // period
    //
    if (n.name () == "period" && n.namespace_ ().empty ())
    {
      if (!period_.present ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    // from
    //
    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      if (!from_.present ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }
    }

    // to
    //
    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      if (!to_.present ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    // num_bins
    //
    if (n.name () == "num_bins" && n.namespace_ ().empty ())
    {
      if (!num_bins_.present ())
      {
        this->num_bins_.set (num_bins_traits::create (i, f, this));
        continue;
      }
    }

    // profile_axis
    //
    if (n.name () == "profile_axis" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< profile_axis_type > r (
        profile_axis_traits::create (i, f, this));

      if (!this->profile_axis_)
      {
        this->profile_axis_.set (::std::move (r));
        continue;
      }
    }

    // velocity_axis
    //
    if (n.name () == "velocity_axis" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_axis_type > r (
        velocity_axis_traits::create (i, f, this));

      if (!this->velocity_axis_)
      {
        this->velocity_axis_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "period",
      "");
  }

  if (!from_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "from",
      "");
  }

  if (!to_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "to",
      "");
  }

  if (!num_bins_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "num_bins",
      "");
  }
}

StatisticsType* StatisticsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StatisticsType (*this, f, c);
}

StatisticsType& StatisticsType::
operator= (const StatisticsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->output_ = x.output_;
    this->period_ = x.period_;
    this->from_ = x.from_;
    this->to_ = x.to_;
    this->num_bins_ = x.num_bins_;
    this->profile_axis_ = x.profile_axis_;
    this->velocity_axis_ = x.velocity_axis_;
  }

  return *this;
}

StatisticsType::
~StatisticsType ()
{
}

// SimulationParameters
//

const SimulationParameters::output_type SimulationParameters::output_default_value_ (
  "");

const SimulationParameters::format_type SimulationParameters::format_default_value_ (
  "vtu");

const SimulationParameters::force_type SimulationParameters::force_default_value_ (
  "Lennard-Jones");

SimulationParameters::
SimulationParameters ()
: ::xml_schema::type (),
  start_time_ (this),
  end_time_ (this),
  delta_t_ (this),
  frequency_ (this),
  output_ (this),
  format_ (this),
  force_ (this),
  g_ (this),
  dimension_ (this),
  thermostat_ (this),
  linked_cell_ (this),
  store_ (this),
  statistics_ (this)
{
}

SimulationParameters::
SimulationParameters (const SimulationParameters& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  start_time_ (x.start_time_, f, this),
  end_time_ (x.end_time_, f, this),
  delta_t_ (x.delta_t_, f, this),
  frequency_ (x.frequency_, f, this),
  output_ (x.output_, f, this),
  format_ (x.format_, f, this),
  force_ (x.force_, f, this),
  g_ (x.g_, f, this),
  dimension_ (x.dimension_, f, this),
  thermostat_ (x.thermostat_, f, this),
  linked_cell_ (x.linked_cell_, f, this),
  store_ (x.store_, f, this),
  statistics_ (x.statistics_, f, this)
{
}

SimulationParameters::
SimulationParameters (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  start_time_ (this),
  end_time_ (this),
  delta_t_ (this),
  frequency_ (this),
  output_ (this),
  format_ (this),
  force_ (this),
  g_ (this),
  dimension_ (this),
  thermostat_ (this),
  linked_cell_ (this),
  store_ (this),
  statistics_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SimulationParameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // start_time
    //
    if (n.name () == "start_time" && n.namespace_ ().empty ())
    {
      if (!this->start_time_)
      {
        this->start_time_.set (start_time_traits::create (i, f, this));
        continue;
      }
    }

    // end_time
    //
    if (n.name () == "end_time" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< end_time_type > r (
        end_time_traits::create (i, f, this));

      if (!this->end_time_)
      {
        this->end_time_.set (::std::move (r));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< delta_t_type > r (
        delta_t_traits::create (i, f, this));

      if (!this->delta_t_)
      {
        this->delta_t_.set (::std::move (r));
        continue;
      }
    }

    // frequency
    //
    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      if (!this->frequency_)
      {
        this->frequency_.set (frequency_traits::create (i, f, this));
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!this->output_)
      {
        this->output_.set (::std::move (r));
        continue;
      }
    }

    // format
    //
    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< format_type > r (
        format_traits::create (i, f, this));

      if (!this->format_)
      {
        this->format_.set (::std::move (r));
        continue;
      }
    }

    // force
    //
    if (n.name () == "force" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< force_type > r (
        force_traits::create (i, f, this));

      if (!this->force_)
      {
        this->force_.set (::std::move (r));
        continue;
      }
    }

    // g
    //
    if (n.name () == "g" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< g_type > r (
        g_traits::create (i, f, this));

      if (!this->g_)
      {
        this->g_.set (::std::move (r));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimension_type > r (
        dimension_traits::create (i, f, this));

      if (!this->dimension_)
      {
        this->dimension_.set (::std::move (r));
        continue;
      }
    }

    // thermostat
    //
    if (n.name () == "thermostat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostat_type > r (
        thermostat_traits::create (i, f, this));

      if (!this->thermostat_)
      {
        this->thermostat_.set (::std::move (r));
        continue;
      }
    }

    // linked_cell
    //
    if (n.name () == "linked_cell" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< linked_cell_type > r (
        linked_cell_traits::create (i, f, this));

      if (!this->linked_cell_)
      {
        this->linked_cell_.set (::std::move (r));
        continue;
      }
    }

    // store
    //
    if (n.name () == "store" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< store_type > r (
        store_traits::create (i, f, this));

      if (!this->store_)
      {
        this->store_.set (::std::move (r));
        continue;
      }
    }

    // statistics
    //
    if (n.name () == "statistics" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< statistics_type > r (
        statistics_traits::create (i, f, this));

      if (!this->statistics_)
      {
        this->statistics_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

SimulationParameters* SimulationParameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimulationParameters (*this, f, c);
}

SimulationParameters& SimulationParameters::
operator= (const SimulationParameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->start_time_ = x.start_time_;
    this->end_time_ = x.end_time_;
    this->delta_t_ = x.delta_t_;
    this->frequency_ = x.frequency_;
    this->output_ = x.output_;
    this->format_ = x.format_;
    this->force_ = x.force_;
    this->g_ = x.g_;
    this->dimension_ = x.dimension_;
    this->thermostat_ = x.thermostat_;
    this->linked_cell_ = x.linked_cell_;
    this->store_ = x.store_;
    this->statistics_ = x.statistics_;
  }

  return *this;
}

SimulationParameters::
~SimulationParameters ()
{
}

// InputData
//

InputData::
InputData (const objects_type& objects,
           const parameters_type& parameters)
: ::xml_schema::type (),
  objects_ (objects, this),
  parameters_ (parameters, this)
{
}

InputData::
InputData (::std::unique_ptr< objects_type > objects,
           ::std::unique_ptr< parameters_type > parameters)
: ::xml_schema::type (),
  objects_ (std::move (objects), this),
  parameters_ (std::move (parameters), this)
{
}

InputData::
InputData (const InputData& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  objects_ (x.objects_, f, this),
  parameters_ (x.parameters_, f, this)
{
}

InputData::
InputData (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  objects_ (this),
  parameters_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void InputData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!objects_.present ())
      {
        this->objects_.set (::std::move (r));
        continue;
      }
    }

    // parameters
    //
    if (n.name () == "parameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parameters_type > r (
        parameters_traits::create (i, f, this));

      if (!parameters_.present ())
      {
        this->parameters_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objects",
      "");
  }

  if (!parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parameters",
      "");
  }
}

InputData* InputData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InputData (*this, f, c);
}

InputData& InputData::
operator= (const InputData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->objects_ = x.objects_;
    this->parameters_ = x.parameters_;
  }

  return *this;
}

InputData::
~InputData ()
{
}

// strategy
//

strategy::
strategy (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

strategy::
strategy (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

strategy::
strategy (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

strategy* strategy::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class strategy (*this, f, c);
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::InputData > (
      ::simulation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::InputData > r (
      ::xsd::cxx::tree::traits< ::InputData, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::unique_ptr< ::InputData >
simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::InputData > r (
      ::xsd::cxx::tree::traits< ::InputData, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const Dimension& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Dimension& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Dimension& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const PositiveDouble& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PositiveDouble& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PositiveDouble& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DoubleVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const OptionalDoubleVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  if (i.x ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(*i.x ());
  }

  // y
  //
  if (i.y ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(*i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PositiveIntVector2& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << i.x ();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << i.y ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PositiveIntVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << i.x ();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << i.y ();
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << *i.z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PositiveDoubleVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << i.x ();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << i.y ();
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << *i.z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ParticleType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "position",
        e));

    s << i.position ();
  }

  // velocity
  //
  if (i.velocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << *i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << i.mass ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *i.type ();
  }

  // epsilon
  //
  if (i.epsilon ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "epsilon",
        e));

    s << ::xml_schema::as_double(*i.epsilon ());
  }

  // sigma
  //
  if (i.sigma ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sigma",
        e));

    s << ::xml_schema::as_double(*i.sigma ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const CuboidType& i)
{
  e << static_cast< const ::ParticleType& > (i);

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        e));

    s << i.size ();
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << i.distance ();
  }

  // brown_velocity
  //
  if (i.brown_velocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brown_velocity",
        e));

    s << ::xml_schema::as_double(*i.brown_velocity ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const SphereType& i)
{
  e << static_cast< const ::ParticleType& > (i);

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << i.distance ();
  }

  // brown_velocity
  //
  if (i.brown_velocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brown_velocity",
        e));

    s << ::xml_schema::as_double(*i.brown_velocity ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ExternalForceType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // index
  //
  for (ExternalForceType::index_const_iterator
       b (i.index ().begin ()), n (i.index ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "index",
        e));

    s << *b;
  }

  // force
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "force",
        e));

    s << i.force ();
  }

  // until
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "until",
        e));

    s << i.until ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MembraneType& i)
{
  e << static_cast< const ::ParticleType& > (i);

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        e));

    s << i.size ();
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << i.distance ();
  }

  // brown_velocity
  //
  if (i.brown_velocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brown_velocity",
        e));

    s << ::xml_schema::as_double(*i.brown_velocity ());
  }

  // k
  //
  if (i.k ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "k",
        e));

    s << *i.k ();
  }

  // r0
  //
  if (i.r0 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "r0",
        e));

    s << *i.r0 ();
  }

  // external_force
  //
  for (MembraneType::external_force_const_iterator
       b (i.external_force ().begin ()), n (i.external_force ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "external_force",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const WallType& i)
{
  e << static_cast< const ::ParticleType& > (i);

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        e));

    s << i.size ();
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << i.distance ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SimulationObjects& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // particle
  //
  for (SimulationObjects::particle_const_iterator
       b (i.particle ().begin ()), n (i.particle ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particle",
        e));

    s << *b;
  }

  // cuboid
  //
  for (SimulationObjects::cuboid_const_iterator
       b (i.cuboid ().begin ()), n (i.cuboid ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboid",
        e));

    s << *b;
  }

  // sphere
  //
  for (SimulationObjects::sphere_const_iterator
       b (i.sphere ().begin ()), n (i.sphere ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sphere",
        e));

    s << *b;
  }

  // membrane
  //
  for (SimulationObjects::membrane_const_iterator
       b (i.membrane ().begin ()), n (i.membrane ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "membrane",
        e));

    s << *b;
  }

  // wall
  //
  for (SimulationObjects::wall_const_iterator
       b (i.wall ().begin ()), n (i.wall ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "wall",
        e));

    s << *b;
  }

  // load
  //
  for (SimulationObjects::load_const_iterator
       b (i.load ().begin ()), n (i.load ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "load",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryConditionType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const BoundaryConditionType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const BoundaryConditionType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryCondition3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // left
  //
  if (i.left ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << *i.left ();
  }

  // right
  //
  if (i.right ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << *i.right ();
  }

  // down
  //
  if (i.down ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "down",
        e));

    s << *i.down ();
  }

  // up
  //
  if (i.up ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "up",
        e));

    s << *i.up ();
  }

  // back
  //
  if (i.back ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "back",
        e));

    s << *i.back ();
  }

  // front
  //
  if (i.front ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "front",
        e));

    s << *i.front ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ForceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const OutputFormatType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const OutputFormatType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const OutputFormatType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const LinkedCellType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // domain_size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domain_size",
        e));

    s << i.domain_size ();
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cutoff_radius",
        e));

    s << i.cutoff_radius ();
  }

  // boundary_condition
  //
  if (i.boundary_condition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_condition",
        e));

    s << *i.boundary_condition ();
  }

  // strategy
  //
  if (i.strategy ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "strategy",
        e));

    s << *i.strategy ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ThermostatsType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // initial_T
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "initial_T",
        e));

    s << i.initial_T ();
  }

  // target_T
  //
  if (i.target_T ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "target_T",
        e));

    s << *i.target_T ();
  }

  // period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "period",
        e));

    s << i.period ();
  }

  // max_delta
  //
  if (i.max_delta ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "max_delta",
        e));

    s << *i.max_delta ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AxisType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AxisType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AxisType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const StatisticsType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // output
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "output",
        e));

    s << i.output ();
  }

  // period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "period",
        e));

    s << i.period ();
  }

  // from
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "from",
        e));

    s << ::xml_schema::as_double(i.from ());
  }

  // to
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "to",
        e));

    s << ::xml_schema::as_double(i.to ());
  }

  // num_bins
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "num_bins",
        e));

    s << i.num_bins ();
  }

  // profile_axis
  //
  if (i.profile_axis ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "profile_axis",
        e));

    s << *i.profile_axis ();
  }

  // velocity_axis
  //
  if (i.velocity_axis ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity_axis",
        e));

    s << *i.velocity_axis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SimulationParameters& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // start_time
  //
  if (i.start_time ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "start_time",
        e));

    s << ::xml_schema::as_double(*i.start_time ());
  }

  // end_time
  //
  if (i.end_time ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "end_time",
        e));

    s << *i.end_time ();
  }

  // delta_t
  //
  if (i.delta_t ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "delta_t",
        e));

    s << *i.delta_t ();
  }

  // frequency
  //
  if (i.frequency ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "frequency",
        e));

    s << *i.frequency ();
  }

  // output
  //
  if (i.output ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "output",
        e));

    s << *i.output ();
  }

  // format
  //
  if (i.format ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "format",
        e));

    s << *i.format ();
  }

  // force
  //
  if (i.force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "force",
        e));

    s << *i.force ();
  }

  // g
  //
  if (i.g ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "g",
        e));

    s << *i.g ();
  }

  // dimension
  //
  if (i.dimension ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dimension",
        e));

    s << *i.dimension ();
  }

  // thermostat
  //
  if (i.thermostat ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "thermostat",
        e));

    s << *i.thermostat ();
  }

  // linked_cell
  //
  if (i.linked_cell ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "linked_cell",
        e));

    s << *i.linked_cell ();
  }

  // store
  //
  if (i.store ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "store",
        e));

    s << *i.store ();
  }

  // statistics
  //
  if (i.statistics ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "statistics",
        e));

    s << *i.statistics ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InputData& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "objects",
        e));

    s << i.objects ();
  }

  // parameters
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parameters",
        e));

    s << i.parameters ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::DOMDocument& d,
            const ::InputData& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
simulation (const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "simulation",
      "",
      m, f));

  ::simulation (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const strategy& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const strategy& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const strategy& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

