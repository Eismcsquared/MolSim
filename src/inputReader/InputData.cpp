// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "InputData.h"

// Dimension
// 


// PositiveDouble
// 


// DoubleVector3
// 

const DoubleVector3::x_type& DoubleVector3::
x () const
{
  return this->x_.get ();
}

DoubleVector3::x_type& DoubleVector3::
x ()
{
  return this->x_.get ();
}

void DoubleVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

const DoubleVector3::y_type& DoubleVector3::
y () const
{
  return this->y_.get ();
}

DoubleVector3::y_type& DoubleVector3::
y ()
{
  return this->y_.get ();
}

void DoubleVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

const DoubleVector3::z_optional& DoubleVector3::
z () const
{
  return this->z_;
}

DoubleVector3::z_optional& DoubleVector3::
z ()
{
  return this->z_;
}

void DoubleVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void DoubleVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

DoubleVector3::z_type DoubleVector3::
z_default_value ()
{
  return z_type (0.0);
}


// PositiveIntVector3
// 

const PositiveIntVector3::x_type& PositiveIntVector3::
x () const
{
  return this->x_.get ();
}

PositiveIntVector3::x_type& PositiveIntVector3::
x ()
{
  return this->x_.get ();
}

void PositiveIntVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

const PositiveIntVector3::y_type& PositiveIntVector3::
y () const
{
  return this->y_.get ();
}

PositiveIntVector3::y_type& PositiveIntVector3::
y ()
{
  return this->y_.get ();
}

void PositiveIntVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

const PositiveIntVector3::z_optional& PositiveIntVector3::
z () const
{
  return this->z_;
}

PositiveIntVector3::z_optional& PositiveIntVector3::
z ()
{
  return this->z_;
}

void PositiveIntVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void PositiveIntVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

PositiveIntVector3::z_type PositiveIntVector3::
z_default_value ()
{
  return z_type (1ULL);
}


// PositiveDoubleVector3
// 

const PositiveDoubleVector3::x_type& PositiveDoubleVector3::
x () const
{
  return this->x_.get ();
}

PositiveDoubleVector3::x_type& PositiveDoubleVector3::
x ()
{
  return this->x_.get ();
}

void PositiveDoubleVector3::
x (const x_type& x)
{
  this->x_.set (x);
}

void PositiveDoubleVector3::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const PositiveDoubleVector3::y_type& PositiveDoubleVector3::
y () const
{
  return this->y_.get ();
}

PositiveDoubleVector3::y_type& PositiveDoubleVector3::
y ()
{
  return this->y_.get ();
}

void PositiveDoubleVector3::
y (const y_type& x)
{
  this->y_.set (x);
}

void PositiveDoubleVector3::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const PositiveDoubleVector3::z_optional& PositiveDoubleVector3::
z () const
{
  return this->z_;
}

PositiveDoubleVector3::z_optional& PositiveDoubleVector3::
z ()
{
  return this->z_;
}

void PositiveDoubleVector3::
z (const z_type& x)
{
  this->z_.set (x);
}

void PositiveDoubleVector3::
z (const z_optional& x)
{
  this->z_ = x;
}

void PositiveDoubleVector3::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}

PositiveDoubleVector3::z_type PositiveDoubleVector3::
z_default_value ()
{
  return z_type (1.0);
}


// ParticleType
// 

const ParticleType::position_type& ParticleType::
position () const
{
  return this->position_.get ();
}

ParticleType::position_type& ParticleType::
position ()
{
  return this->position_.get ();
}

void ParticleType::
position (const position_type& x)
{
  this->position_.set (x);
}

void ParticleType::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const ParticleType::velocity_type& ParticleType::
velocity () const
{
  return this->velocity_.get ();
}

ParticleType::velocity_type& ParticleType::
velocity ()
{
  return this->velocity_.get ();
}

void ParticleType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void ParticleType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const ParticleType::mass_type& ParticleType::
mass () const
{
  return this->mass_.get ();
}

ParticleType::mass_type& ParticleType::
mass ()
{
  return this->mass_.get ();
}

void ParticleType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void ParticleType::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}

const ParticleType::type_optional& ParticleType::
type () const
{
  return this->type_;
}

ParticleType::type_optional& ParticleType::
type ()
{
  return this->type_;
}

void ParticleType::
type (const type_type& x)
{
  this->type_.set (x);
}

void ParticleType::
type (const type_optional& x)
{
  this->type_ = x;
}

ParticleType::type_type ParticleType::
type_default_value ()
{
  return type_type (0);
}


// CuboidType
// 

const CuboidType::position_type& CuboidType::
position () const
{
  return this->position_.get ();
}

CuboidType::position_type& CuboidType::
position ()
{
  return this->position_.get ();
}

void CuboidType::
position (const position_type& x)
{
  this->position_.set (x);
}

void CuboidType::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const CuboidType::velocity_type& CuboidType::
velocity () const
{
  return this->velocity_.get ();
}

CuboidType::velocity_type& CuboidType::
velocity ()
{
  return this->velocity_.get ();
}

void CuboidType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void CuboidType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const CuboidType::mass_type& CuboidType::
mass () const
{
  return this->mass_.get ();
}

CuboidType::mass_type& CuboidType::
mass ()
{
  return this->mass_.get ();
}

void CuboidType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void CuboidType::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}

const CuboidType::size_type& CuboidType::
size () const
{
  return this->size_.get ();
}

CuboidType::size_type& CuboidType::
size ()
{
  return this->size_.get ();
}

void CuboidType::
size (const size_type& x)
{
  this->size_.set (x);
}

void CuboidType::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const CuboidType::distance_type& CuboidType::
distance () const
{
  return this->distance_.get ();
}

CuboidType::distance_type& CuboidType::
distance ()
{
  return this->distance_.get ();
}

void CuboidType::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void CuboidType::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}

const CuboidType::brownVelocity_type& CuboidType::
brownVelocity () const
{
  return this->brownVelocity_.get ();
}

CuboidType::brownVelocity_type& CuboidType::
brownVelocity ()
{
  return this->brownVelocity_.get ();
}

void CuboidType::
brownVelocity (const brownVelocity_type& x)
{
  this->brownVelocity_.set (x);
}

void CuboidType::
brownVelocity (::std::unique_ptr< brownVelocity_type > x)
{
  this->brownVelocity_.set (std::move (x));
}

const CuboidType::brownDimension_optional& CuboidType::
brownDimension () const
{
  return this->brownDimension_;
}

CuboidType::brownDimension_optional& CuboidType::
brownDimension ()
{
  return this->brownDimension_;
}

void CuboidType::
brownDimension (const brownDimension_type& x)
{
  this->brownDimension_.set (x);
}

void CuboidType::
brownDimension (const brownDimension_optional& x)
{
  this->brownDimension_ = x;
}

void CuboidType::
brownDimension (::std::unique_ptr< brownDimension_type > x)
{
  this->brownDimension_.set (std::move (x));
}

CuboidType::brownDimension_type CuboidType::
brownDimension_default_value ()
{
  return brownDimension_type (3ULL);
}


// SimulationObjects
// 

const SimulationObjects::particle_sequence& SimulationObjects::
particle () const
{
  return this->particle_;
}

SimulationObjects::particle_sequence& SimulationObjects::
particle ()
{
  return this->particle_;
}

void SimulationObjects::
particle (const particle_sequence& s)
{
  this->particle_ = s;
}

const SimulationObjects::cuboid_sequence& SimulationObjects::
cuboid () const
{
  return this->cuboid_;
}

SimulationObjects::cuboid_sequence& SimulationObjects::
cuboid ()
{
  return this->cuboid_;
}

void SimulationObjects::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


// BoundaryConditionType
// 

BoundaryConditionType::
BoundaryConditionType (value v)
: ::xml_schema::string (_xsd_BoundaryConditionType_literals_[v])
{
}

BoundaryConditionType::
BoundaryConditionType (const char* v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const BoundaryConditionType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

BoundaryConditionType& BoundaryConditionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_BoundaryConditionType_literals_[v]);

  return *this;
}


// BoundaryCondition3
// 

const BoundaryCondition3::left_optional& BoundaryCondition3::
left () const
{
  return this->left_;
}

BoundaryCondition3::left_optional& BoundaryCondition3::
left ()
{
  return this->left_;
}

void BoundaryCondition3::
left (const left_type& x)
{
  this->left_.set (x);
}

void BoundaryCondition3::
left (const left_optional& x)
{
  this->left_ = x;
}

void BoundaryCondition3::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const BoundaryCondition3::left_type& BoundaryCondition3::
left_default_value ()
{
  return left_default_value_;
}

const BoundaryCondition3::right_optional& BoundaryCondition3::
right () const
{
  return this->right_;
}

BoundaryCondition3::right_optional& BoundaryCondition3::
right ()
{
  return this->right_;
}

void BoundaryCondition3::
right (const right_type& x)
{
  this->right_.set (x);
}

void BoundaryCondition3::
right (const right_optional& x)
{
  this->right_ = x;
}

void BoundaryCondition3::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const BoundaryCondition3::right_type& BoundaryCondition3::
right_default_value ()
{
  return right_default_value_;
}

const BoundaryCondition3::down_optional& BoundaryCondition3::
down () const
{
  return this->down_;
}

BoundaryCondition3::down_optional& BoundaryCondition3::
down ()
{
  return this->down_;
}

void BoundaryCondition3::
down (const down_type& x)
{
  this->down_.set (x);
}

void BoundaryCondition3::
down (const down_optional& x)
{
  this->down_ = x;
}

void BoundaryCondition3::
down (::std::unique_ptr< down_type > x)
{
  this->down_.set (std::move (x));
}

const BoundaryCondition3::down_type& BoundaryCondition3::
down_default_value ()
{
  return down_default_value_;
}

const BoundaryCondition3::up_optional& BoundaryCondition3::
up () const
{
  return this->up_;
}

BoundaryCondition3::up_optional& BoundaryCondition3::
up ()
{
  return this->up_;
}

void BoundaryCondition3::
up (const up_type& x)
{
  this->up_.set (x);
}

void BoundaryCondition3::
up (const up_optional& x)
{
  this->up_ = x;
}

void BoundaryCondition3::
up (::std::unique_ptr< up_type > x)
{
  this->up_.set (std::move (x));
}

const BoundaryCondition3::up_type& BoundaryCondition3::
up_default_value ()
{
  return up_default_value_;
}

const BoundaryCondition3::back_optional& BoundaryCondition3::
back () const
{
  return this->back_;
}

BoundaryCondition3::back_optional& BoundaryCondition3::
back ()
{
  return this->back_;
}

void BoundaryCondition3::
back (const back_type& x)
{
  this->back_.set (x);
}

void BoundaryCondition3::
back (const back_optional& x)
{
  this->back_ = x;
}

void BoundaryCondition3::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}

const BoundaryCondition3::back_type& BoundaryCondition3::
back_default_value ()
{
  return back_default_value_;
}

const BoundaryCondition3::front_optional& BoundaryCondition3::
front () const
{
  return this->front_;
}

BoundaryCondition3::front_optional& BoundaryCondition3::
front ()
{
  return this->front_;
}

void BoundaryCondition3::
front (const front_type& x)
{
  this->front_.set (x);
}

void BoundaryCondition3::
front (const front_optional& x)
{
  this->front_ = x;
}

void BoundaryCondition3::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const BoundaryCondition3::front_type& BoundaryCondition3::
front_default_value ()
{
  return front_default_value_;
}


// ForceType
// 

ForceType::
ForceType (value v)
: ::xml_schema::string (_xsd_ForceType_literals_[v])
{
}

ForceType::
ForceType (const char* v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ForceType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ForceType& ForceType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ForceType_literals_[v]);

  return *this;
}


// OutputFormatType
// 

OutputFormatType::
OutputFormatType (value v)
: ::xml_schema::string (_xsd_OutputFormatType_literals_[v])
{
}

OutputFormatType::
OutputFormatType (const char* v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

OutputFormatType::
OutputFormatType (const OutputFormatType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

OutputFormatType& OutputFormatType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_OutputFormatType_literals_[v]);

  return *this;
}


// LinkedCellType
// 

const LinkedCellType::domain_size_type& LinkedCellType::
domain_size () const
{
  return this->domain_size_.get ();
}

LinkedCellType::domain_size_type& LinkedCellType::
domain_size ()
{
  return this->domain_size_.get ();
}

void LinkedCellType::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void LinkedCellType::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const LinkedCellType::cutoff_radius_type& LinkedCellType::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

LinkedCellType::cutoff_radius_type& LinkedCellType::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void LinkedCellType::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void LinkedCellType::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}

const LinkedCellType::boundary_condition_type& LinkedCellType::
boundary_condition () const
{
  return this->boundary_condition_.get ();
}

LinkedCellType::boundary_condition_type& LinkedCellType::
boundary_condition ()
{
  return this->boundary_condition_.get ();
}

void LinkedCellType::
boundary_condition (const boundary_condition_type& x)
{
  this->boundary_condition_.set (x);
}

void LinkedCellType::
boundary_condition (::std::unique_ptr< boundary_condition_type > x)
{
  this->boundary_condition_.set (std::move (x));
}


// SimulationParameters
// 

const SimulationParameters::end_time_optional& SimulationParameters::
end_time () const
{
  return this->end_time_;
}

SimulationParameters::end_time_optional& SimulationParameters::
end_time ()
{
  return this->end_time_;
}

void SimulationParameters::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

void SimulationParameters::
end_time (const end_time_optional& x)
{
  this->end_time_ = x;
}

void SimulationParameters::
end_time (::std::unique_ptr< end_time_type > x)
{
  this->end_time_.set (std::move (x));
}

SimulationParameters::end_time_type SimulationParameters::
end_time_default_value ()
{
  return end_time_type (5.0);
}

const SimulationParameters::delta_t_optional& SimulationParameters::
delta_t () const
{
  return this->delta_t_;
}

SimulationParameters::delta_t_optional& SimulationParameters::
delta_t ()
{
  return this->delta_t_;
}

void SimulationParameters::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

void SimulationParameters::
delta_t (const delta_t_optional& x)
{
  this->delta_t_ = x;
}

void SimulationParameters::
delta_t (::std::unique_ptr< delta_t_type > x)
{
  this->delta_t_.set (std::move (x));
}

SimulationParameters::delta_t_type SimulationParameters::
delta_t_default_value ()
{
  return delta_t_type (.0002);
}

const SimulationParameters::frequency_optional& SimulationParameters::
frequency () const
{
  return this->frequency_;
}

SimulationParameters::frequency_optional& SimulationParameters::
frequency ()
{
  return this->frequency_;
}

void SimulationParameters::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}

void SimulationParameters::
frequency (const frequency_optional& x)
{
  this->frequency_ = x;
}

SimulationParameters::frequency_type SimulationParameters::
frequency_default_value ()
{
  return frequency_type (10ULL);
}

const SimulationParameters::output_optional& SimulationParameters::
output () const
{
  return this->output_;
}

SimulationParameters::output_optional& SimulationParameters::
output ()
{
  return this->output_;
}

void SimulationParameters::
output (const output_type& x)
{
  this->output_.set (x);
}

void SimulationParameters::
output (const output_optional& x)
{
  this->output_ = x;
}

void SimulationParameters::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const SimulationParameters::output_type& SimulationParameters::
output_default_value ()
{
  return output_default_value_;
}

const SimulationParameters::format_optional& SimulationParameters::
format () const
{
  return this->format_;
}

SimulationParameters::format_optional& SimulationParameters::
format ()
{
  return this->format_;
}

void SimulationParameters::
format (const format_type& x)
{
  this->format_.set (x);
}

void SimulationParameters::
format (const format_optional& x)
{
  this->format_ = x;
}

void SimulationParameters::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}

const SimulationParameters::format_type& SimulationParameters::
format_default_value ()
{
  return format_default_value_;
}

const SimulationParameters::force_optional& SimulationParameters::
force () const
{
  return this->force_;
}

SimulationParameters::force_optional& SimulationParameters::
force ()
{
  return this->force_;
}

void SimulationParameters::
force (const force_type& x)
{
  this->force_.set (x);
}

void SimulationParameters::
force (const force_optional& x)
{
  this->force_ = x;
}

void SimulationParameters::
force (::std::unique_ptr< force_type > x)
{
  this->force_.set (std::move (x));
}

const SimulationParameters::force_type& SimulationParameters::
force_default_value ()
{
  return force_default_value_;
}

const SimulationParameters::linked_cell_optional& SimulationParameters::
linked_cell () const
{
  return this->linked_cell_;
}

SimulationParameters::linked_cell_optional& SimulationParameters::
linked_cell ()
{
  return this->linked_cell_;
}

void SimulationParameters::
linked_cell (const linked_cell_type& x)
{
  this->linked_cell_.set (x);
}

void SimulationParameters::
linked_cell (const linked_cell_optional& x)
{
  this->linked_cell_ = x;
}

void SimulationParameters::
linked_cell (::std::unique_ptr< linked_cell_type > x)
{
  this->linked_cell_.set (std::move (x));
}


// InputData
// 

const InputData::objects_type& InputData::
objects () const
{
  return this->objects_.get ();
}

InputData::objects_type& InputData::
objects ()
{
  return this->objects_.get ();
}

void InputData::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void InputData::
objects (::std::unique_ptr< objects_type > x)
{
  this->objects_.set (std::move (x));
}

const InputData::parameters_type& InputData::
parameters () const
{
  return this->parameters_.get ();
}

InputData::parameters_type& InputData::
parameters ()
{
  return this->parameters_.get ();
}

void InputData::
parameters (const parameters_type& x)
{
  this->parameters_.set (x);
}

void InputData::
parameters (::std::unique_ptr< parameters_type > x)
{
  this->parameters_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Dimension
//

Dimension::
Dimension (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
{
}

Dimension::
Dimension (const Dimension& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

Dimension::
Dimension (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

Dimension::
Dimension (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

Dimension::
Dimension (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

Dimension* Dimension::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Dimension (*this, f, c);
}

Dimension::
~Dimension ()
{
}

// PositiveDouble
//

PositiveDouble::
PositiveDouble (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

PositiveDouble::
PositiveDouble (const PositiveDouble& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

PositiveDouble::
PositiveDouble (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

PositiveDouble* PositiveDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDouble (*this, f, c);
}

PositiveDouble::
~PositiveDouble ()
{
}

// DoubleVector3
//

DoubleVector3::
DoubleVector3 (const x_type& x,
               const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

DoubleVector3::
DoubleVector3 (const DoubleVector3& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

DoubleVector3::
DoubleVector3 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DoubleVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!this->z_)
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

DoubleVector3* DoubleVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoubleVector3 (*this, f, c);
}

DoubleVector3& DoubleVector3::
operator= (const DoubleVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

DoubleVector3::
~DoubleVector3 ()
{
}

// PositiveIntVector3
//

PositiveIntVector3::
PositiveIntVector3 (const x_type& x,
                    const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

PositiveIntVector3::
PositiveIntVector3 (const PositiveIntVector3& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

PositiveIntVector3::
PositiveIntVector3 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PositiveIntVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!this->z_)
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

PositiveIntVector3* PositiveIntVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveIntVector3 (*this, f, c);
}

PositiveIntVector3& PositiveIntVector3::
operator= (const PositiveIntVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

PositiveIntVector3::
~PositiveIntVector3 ()
{
}

// PositiveDoubleVector3
//

PositiveDoubleVector3::
PositiveDoubleVector3 (const x_type& x,
                       const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

PositiveDoubleVector3::
PositiveDoubleVector3 (const PositiveDoubleVector3& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

PositiveDoubleVector3::
PositiveDoubleVector3 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PositiveDoubleVector3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< x_type > r (
        x_traits::create (i, f, this));

      if (!x_.present ())
      {
        this->x_.set (::std::move (r));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< y_type > r (
        y_traits::create (i, f, this));

      if (!y_.present ())
      {
        this->y_.set (::std::move (r));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< z_type > r (
        z_traits::create (i, f, this));

      if (!this->z_)
      {
        this->z_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

PositiveDoubleVector3* PositiveDoubleVector3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDoubleVector3 (*this, f, c);
}

PositiveDoubleVector3& PositiveDoubleVector3::
operator= (const PositiveDoubleVector3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

PositiveDoubleVector3::
~PositiveDoubleVector3 ()
{
}

// ParticleType
//

ParticleType::
ParticleType (const position_type& position,
              const velocity_type& velocity,
              const mass_type& mass)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  mass_ (mass, this),
  type_ (this)
{
}

ParticleType::
ParticleType (::std::unique_ptr< position_type > position,
              ::std::unique_ptr< velocity_type > velocity,
              const mass_type& mass)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this),
  type_ (this)
{
}

ParticleType::
ParticleType (const ParticleType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  type_ (x.type_, f, this)
{
}

ParticleType::
ParticleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  mass_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParticleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!this->type_)
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

ParticleType* ParticleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParticleType (*this, f, c);
}

ParticleType& ParticleType::
operator= (const ParticleType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->type_ = x.type_;
  }

  return *this;
}

ParticleType::
~ParticleType ()
{
}

// CuboidType
//

CuboidType::
CuboidType (const position_type& position,
            const velocity_type& velocity,
            const mass_type& mass,
            const size_type& size,
            const distance_type& distance,
            const brownVelocity_type& brownVelocity)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  mass_ (mass, this),
  size_ (size, this),
  distance_ (distance, this),
  brownVelocity_ (brownVelocity, this),
  brownDimension_ (this)
{
}

CuboidType::
CuboidType (::std::unique_ptr< position_type > position,
            ::std::unique_ptr< velocity_type > velocity,
            const mass_type& mass,
            ::std::unique_ptr< size_type > size,
            const distance_type& distance,
            const brownVelocity_type& brownVelocity)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this),
  size_ (std::move (size), this),
  distance_ (distance, this),
  brownVelocity_ (brownVelocity, this),
  brownDimension_ (this)
{
}

CuboidType::
CuboidType (const CuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  size_ (x.size_, f, this),
  distance_ (x.distance_, f, this),
  brownVelocity_ (x.brownVelocity_, f, this),
  brownDimension_ (x.brownDimension_, f, this)
{
}

CuboidType::
CuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  mass_ (this),
  size_ (this),
  distance_ (this),
  brownVelocity_ (this),
  brownDimension_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    // size
    //
    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< distance_type > r (
        distance_traits::create (i, f, this));

      if (!distance_.present ())
      {
        this->distance_.set (::std::move (r));
        continue;
      }
    }

    // brownVelocity
    //
    if (n.name () == "brownVelocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< brownVelocity_type > r (
        brownVelocity_traits::create (i, f, this));

      if (!brownVelocity_.present ())
      {
        this->brownVelocity_.set (::std::move (r));
        continue;
      }
    }

    // brownDimension
    //
    if (n.name () == "brownDimension" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< brownDimension_type > r (
        brownDimension_traits::create (i, f, this));

      if (!this->brownDimension_)
      {
        this->brownDimension_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!brownVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "brownVelocity",
      "");
  }
}

CuboidType* CuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CuboidType (*this, f, c);
}

CuboidType& CuboidType::
operator= (const CuboidType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->size_ = x.size_;
    this->distance_ = x.distance_;
    this->brownVelocity_ = x.brownVelocity_;
    this->brownDimension_ = x.brownDimension_;
  }

  return *this;
}

CuboidType::
~CuboidType ()
{
}

// SimulationObjects
//

SimulationObjects::
SimulationObjects ()
: ::xml_schema::type (),
  particle_ (this),
  cuboid_ (this)
{
}

SimulationObjects::
SimulationObjects (const SimulationObjects& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_ (x.particle_, f, this),
  cuboid_ (x.cuboid_, f, this)
{
}

SimulationObjects::
SimulationObjects (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_ (this),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SimulationObjects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle
    //
    if (n.name () == "particle" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_type > r (
        particle_traits::create (i, f, this));

      this->particle_.push_back (::std::move (r));
      continue;
    }

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

SimulationObjects* SimulationObjects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimulationObjects (*this, f, c);
}

SimulationObjects& SimulationObjects::
operator= (const SimulationObjects& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particle_ = x.particle_;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

SimulationObjects::
~SimulationObjects ()
{
}

// BoundaryConditionType
//

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType* BoundaryConditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryConditionType (*this, f, c);
}

BoundaryConditionType::value BoundaryConditionType::
_xsd_BoundaryConditionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BoundaryConditionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_BoundaryConditionType_indexes_,
                    _xsd_BoundaryConditionType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_BoundaryConditionType_indexes_ + 3 || _xsd_BoundaryConditionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const BoundaryConditionType::
_xsd_BoundaryConditionType_literals_[3] =
{
  "outflow",
  "reflection",
  "periodic"
};

const BoundaryConditionType::value BoundaryConditionType::
_xsd_BoundaryConditionType_indexes_[3] =
{
  ::BoundaryConditionType::outflow,
  ::BoundaryConditionType::periodic,
  ::BoundaryConditionType::reflection
};

// BoundaryCondition3
//

const BoundaryCondition3::left_type BoundaryCondition3::left_default_value_ (
  "outflow");

const BoundaryCondition3::right_type BoundaryCondition3::right_default_value_ (
  "outflow");

const BoundaryCondition3::down_type BoundaryCondition3::down_default_value_ (
  "outflow");

const BoundaryCondition3::up_type BoundaryCondition3::up_default_value_ (
  "outflow");

const BoundaryCondition3::back_type BoundaryCondition3::back_default_value_ (
  "outflow");

const BoundaryCondition3::front_type BoundaryCondition3::front_default_value_ (
  "outflow");

BoundaryCondition3::
BoundaryCondition3 ()
: ::xml_schema::type (),
  left_ (this),
  right_ (this),
  down_ (this),
  up_ (this),
  back_ (this),
  front_ (this)
{
}

BoundaryCondition3::
BoundaryCondition3 (const BoundaryCondition3& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this),
  down_ (x.down_, f, this),
  up_ (x.up_, f, this),
  back_ (x.back_, f, this),
  front_ (x.front_, f, this)
{
}

BoundaryCondition3::
BoundaryCondition3 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  right_ (this),
  down_ (this),
  up_ (this),
  back_ (this),
  front_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BoundaryCondition3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!this->left_)
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!this->right_)
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // down
    //
    if (n.name () == "down" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< down_type > r (
        down_traits::create (i, f, this));

      if (!this->down_)
      {
        this->down_.set (::std::move (r));
        continue;
      }
    }

    // up
    //
    if (n.name () == "up" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< up_type > r (
        up_traits::create (i, f, this));

      if (!this->up_)
      {
        this->up_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!this->back_)
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!this->front_)
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

BoundaryCondition3* BoundaryCondition3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryCondition3 (*this, f, c);
}

BoundaryCondition3& BoundaryCondition3::
operator= (const BoundaryCondition3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->right_ = x.right_;
    this->down_ = x.down_;
    this->up_ = x.up_;
    this->back_ = x.back_;
    this->front_ = x.front_;
  }

  return *this;
}

BoundaryCondition3::
~BoundaryCondition3 ()
{
}

// ForceType
//

ForceType::
ForceType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType* ForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceType (*this, f, c);
}

ForceType::value ForceType::
_xsd_ForceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceType_indexes_,
                    _xsd_ForceType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ForceType_indexes_ + 2 || _xsd_ForceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceType::
_xsd_ForceType_literals_[2] =
{
  "gravitation",
  "Lennard-Jones"
};

const ForceType::value ForceType::
_xsd_ForceType_indexes_[2] =
{
  ::ForceType::Lennard_Jones,
  ::ForceType::gravitation
};

// OutputFormatType
//

OutputFormatType::
OutputFormatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType::
OutputFormatType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType::
OutputFormatType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_OutputFormatType_convert ();
}

OutputFormatType* OutputFormatType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OutputFormatType (*this, f, c);
}

OutputFormatType::value OutputFormatType::
_xsd_OutputFormatType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OutputFormatType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_OutputFormatType_indexes_,
                    _xsd_OutputFormatType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_OutputFormatType_indexes_ + 2 || _xsd_OutputFormatType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const OutputFormatType::
_xsd_OutputFormatType_literals_[2] =
{
  "vtu",
  "xyz"
};

const OutputFormatType::value OutputFormatType::
_xsd_OutputFormatType_indexes_[2] =
{
  ::OutputFormatType::vtu,
  ::OutputFormatType::xyz
};

// LinkedCellType
//

LinkedCellType::
LinkedCellType (const domain_size_type& domain_size,
                const cutoff_radius_type& cutoff_radius,
                const boundary_condition_type& boundary_condition)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_condition_ (boundary_condition, this)
{
}

LinkedCellType::
LinkedCellType (::std::unique_ptr< domain_size_type > domain_size,
                const cutoff_radius_type& cutoff_radius,
                ::std::unique_ptr< boundary_condition_type > boundary_condition)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_condition_ (std::move (boundary_condition), this)
{
}

LinkedCellType::
LinkedCellType (const LinkedCellType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  boundary_condition_ (x.boundary_condition_, f, this)
{
}

LinkedCellType::
LinkedCellType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  cutoff_radius_ (this),
  boundary_condition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LinkedCellType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cutoff_radius_type > r (
        cutoff_radius_traits::create (i, f, this));

      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (::std::move (r));
        continue;
      }
    }

    // boundary_condition
    //
    if (n.name () == "boundary_condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_condition_type > r (
        boundary_condition_traits::create (i, f, this));

      if (!boundary_condition_.present ())
      {
        this->boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }

  if (!boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary_condition",
      "");
  }
}

LinkedCellType* LinkedCellType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LinkedCellType (*this, f, c);
}

LinkedCellType& LinkedCellType::
operator= (const LinkedCellType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->cutoff_radius_ = x.cutoff_radius_;
    this->boundary_condition_ = x.boundary_condition_;
  }

  return *this;
}

LinkedCellType::
~LinkedCellType ()
{
}

// SimulationParameters
//

const SimulationParameters::output_type SimulationParameters::output_default_value_ (
  "MD_vtk");

const SimulationParameters::format_type SimulationParameters::format_default_value_ (
  "vtu");

const SimulationParameters::force_type SimulationParameters::force_default_value_ (
  "Lennard-Jones");

SimulationParameters::
SimulationParameters ()
: ::xml_schema::type (),
  end_time_ (this),
  delta_t_ (this),
  frequency_ (this),
  output_ (this),
  format_ (this),
  force_ (this),
  linked_cell_ (this)
{
}

SimulationParameters::
SimulationParameters (const SimulationParameters& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  end_time_ (x.end_time_, f, this),
  delta_t_ (x.delta_t_, f, this),
  frequency_ (x.frequency_, f, this),
  output_ (x.output_, f, this),
  format_ (x.format_, f, this),
  force_ (x.force_, f, this),
  linked_cell_ (x.linked_cell_, f, this)
{
}

SimulationParameters::
SimulationParameters (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  end_time_ (this),
  delta_t_ (this),
  frequency_ (this),
  output_ (this),
  format_ (this),
  force_ (this),
  linked_cell_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SimulationParameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // end_time
    //
    if (n.name () == "end_time" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< end_time_type > r (
        end_time_traits::create (i, f, this));

      if (!this->end_time_)
      {
        this->end_time_.set (::std::move (r));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< delta_t_type > r (
        delta_t_traits::create (i, f, this));

      if (!this->delta_t_)
      {
        this->delta_t_.set (::std::move (r));
        continue;
      }
    }

    // frequency
    //
    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      if (!this->frequency_)
      {
        this->frequency_.set (frequency_traits::create (i, f, this));
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!this->output_)
      {
        this->output_.set (::std::move (r));
        continue;
      }
    }

    // format
    //
    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< format_type > r (
        format_traits::create (i, f, this));

      if (!this->format_)
      {
        this->format_.set (::std::move (r));
        continue;
      }
    }

    // force
    //
    if (n.name () == "force" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< force_type > r (
        force_traits::create (i, f, this));

      if (!this->force_)
      {
        this->force_.set (::std::move (r));
        continue;
      }
    }

    // linked_cell
    //
    if (n.name () == "linked_cell" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< linked_cell_type > r (
        linked_cell_traits::create (i, f, this));

      if (!this->linked_cell_)
      {
        this->linked_cell_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

SimulationParameters* SimulationParameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimulationParameters (*this, f, c);
}

SimulationParameters& SimulationParameters::
operator= (const SimulationParameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->end_time_ = x.end_time_;
    this->delta_t_ = x.delta_t_;
    this->frequency_ = x.frequency_;
    this->output_ = x.output_;
    this->format_ = x.format_;
    this->force_ = x.force_;
    this->linked_cell_ = x.linked_cell_;
  }

  return *this;
}

SimulationParameters::
~SimulationParameters ()
{
}

// InputData
//

InputData::
InputData (const objects_type& objects,
           const parameters_type& parameters)
: ::xml_schema::type (),
  objects_ (objects, this),
  parameters_ (parameters, this)
{
}

InputData::
InputData (::std::unique_ptr< objects_type > objects,
           ::std::unique_ptr< parameters_type > parameters)
: ::xml_schema::type (),
  objects_ (std::move (objects), this),
  parameters_ (std::move (parameters), this)
{
}

InputData::
InputData (const InputData& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  objects_ (x.objects_, f, this),
  parameters_ (x.parameters_, f, this)
{
}

InputData::
InputData (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  objects_ (this),
  parameters_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void InputData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!objects_.present ())
      {
        this->objects_.set (::std::move (r));
        continue;
      }
    }

    // parameters
    //
    if (n.name () == "parameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parameters_type > r (
        parameters_traits::create (i, f, this));

      if (!parameters_.present ())
      {
        this->parameters_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objects",
      "");
  }

  if (!parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parameters",
      "");
  }
}

InputData* InputData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InputData (*this, f, c);
}

InputData& InputData::
operator= (const InputData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->objects_ = x.objects_;
    this->parameters_ = x.parameters_;
  }

  return *this;
}

InputData::
~InputData ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::InputData > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::InputData >
simulation (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::InputData > (
      ::simulation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::InputData > r (
      ::xsd::cxx::tree::traits< ::InputData, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::unique_ptr< ::InputData >
simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::InputData > r (
      ::xsd::cxx::tree::traits< ::InputData, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const Dimension& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Dimension& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Dimension& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const PositiveDouble& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PositiveDouble& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PositiveDouble& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DoubleVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PositiveIntVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << i.x ();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << i.y ();
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << *i.z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PositiveDoubleVector3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << i.x ();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << i.y ();
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << *i.z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ParticleType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "position",
        e));

    s << i.position ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << i.mass ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CuboidType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "position",
        e));

    s << i.position ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << i.mass ();
  }

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        e));

    s << i.size ();
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << i.distance ();
  }

  // brownVelocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brownVelocity",
        e));

    s << i.brownVelocity ();
  }

  // brownDimension
  //
  if (i.brownDimension ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brownDimension",
        e));

    s << *i.brownDimension ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SimulationObjects& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // particle
  //
  for (SimulationObjects::particle_const_iterator
       b (i.particle ().begin ()), n (i.particle ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particle",
        e));

    s << *b;
  }

  // cuboid
  //
  for (SimulationObjects::cuboid_const_iterator
       b (i.cuboid ().begin ()), n (i.cuboid ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboid",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryConditionType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const BoundaryConditionType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const BoundaryConditionType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryCondition3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // left
  //
  if (i.left ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << *i.left ();
  }

  // right
  //
  if (i.right ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << *i.right ();
  }

  // down
  //
  if (i.down ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "down",
        e));

    s << *i.down ();
  }

  // up
  //
  if (i.up ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "up",
        e));

    s << *i.up ();
  }

  // back
  //
  if (i.back ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "back",
        e));

    s << *i.back ();
  }

  // front
  //
  if (i.front ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "front",
        e));

    s << *i.front ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ForceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const OutputFormatType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const OutputFormatType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const OutputFormatType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const LinkedCellType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // domain_size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domain_size",
        e));

    s << i.domain_size ();
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cutoff_radius",
        e));

    s << i.cutoff_radius ();
  }

  // boundary_condition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_condition",
        e));

    s << i.boundary_condition ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SimulationParameters& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // end_time
  //
  if (i.end_time ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "end_time",
        e));

    s << *i.end_time ();
  }

  // delta_t
  //
  if (i.delta_t ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "delta_t",
        e));

    s << *i.delta_t ();
  }

  // frequency
  //
  if (i.frequency ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "frequency",
        e));

    s << *i.frequency ();
  }

  // output
  //
  if (i.output ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "output",
        e));

    s << *i.output ();
  }

  // format
  //
  if (i.format ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "format",
        e));

    s << *i.format ();
  }

  // force
  //
  if (i.force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "force",
        e));

    s << *i.force ();
  }

  // linked_cell
  //
  if (i.linked_cell ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "linked_cell",
        e));

    s << *i.linked_cell ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InputData& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "objects",
        e));

    s << i.objects ();
  }

  // parameters
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parameters",
        e));

    s << i.parameters ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::std::ostream& o,
            const ::InputData& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::InputData& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::DOMDocument& d,
            const ::InputData& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
simulation (const ::InputData& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "simulation",
      "",
      m, f));

  ::simulation (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

